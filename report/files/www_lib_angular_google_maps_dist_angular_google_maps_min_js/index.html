<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - www/lib/angular-google-maps/dist/angular-google-maps.min.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>www/lib/angular-google-maps/dist/angular-google-maps.min.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">76.05</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2968</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">409.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">126.48</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*! angular-google-maps 1.2.2 2014-09-25
 *  AngularJS directives for Google Maps
 *  git: https://github.com/nlaplante/angular-google-maps.git
 */
function InfoBox(a) {
	a = a || {}, google.maps.OverlayView.apply(this, arguments), this.content_ = a.content || &quot;&quot;, this.disableAutoPan_ = a.disableAutoPan || !1, this.maxWidth_ = a.maxWidth || 0, this.pixelOffset_ = a.pixelOffset || new google.maps.Size(0, 0), this.position_ = a.position || new google.maps.LatLng(0, 0), this.zIndex_ = a.zIndex || null, this.boxClass_ = a.boxClass || &quot;infoBox&quot;, this.boxStyle_ = a.boxStyle || {}, this.closeBoxMargin_ = a.closeBoxMargin || &quot;2px&quot;, this.closeBoxURL_ = a.closeBoxURL || &quot;http://www.google.com/intl/en_us/mapfiles/close.gif&quot;, &quot;&quot; === a.closeBoxURL &amp;&amp; (this.closeBoxURL_ = &quot;&quot;), this.infoBoxClearance_ = a.infoBoxClearance || new google.maps.Size(1, 1), &quot;undefined&quot; == typeof a.visible &amp;&amp; (a.visible = &quot;undefined&quot; == typeof a.isHidden ? !0 : !a.isHidden), this.isHidden_ = !a.visible, this.alignBottom_ = a.alignBottom || !1, this.pane_ = a.pane || &quot;floatPane&quot;, this.enableEventPropagation_ = a.enableEventPropagation || !1, this.div_ = null, this.closeListener_ = null, this.moveListener_ = null, this.contextListener_ = null, this.eventListeners_ = null, this.fixedWidthSet_ = null
}
function ClusterIcon(a, b) {
	a.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView), this.cluster_ = a, this.className_ = a.getMarkerClusterer().getClusterClass(), this.styles_ = b, this.center_ = null, this.div_ = null, this.sums_ = null, this.visible_ = !1, this.setMap(a.getMap())
}
function Cluster(a) {
	this.markerClusterer_ = a, this.map_ = a.getMap(), this.gridSize_ = a.getGridSize(), this.minClusterSize_ = a.getMinimumClusterSize(), this.averageCenter_ = a.getAverageCenter(), this.markers_ = [], this.center_ = null, this.bounds_ = null, this.clusterIcon_ = new ClusterIcon(this, a.getStyles())
}
function MarkerClusterer(a, b, c) {
	this.extend(MarkerClusterer, google.maps.OverlayView), b = b || [], c = c || {}, this.markers_ = [], this.clusters_ = [], this.listeners_ = [], this.activeMap_ = null, this.ready_ = !1, this.gridSize_ = c.gridSize || 60, this.minClusterSize_ = c.minimumClusterSize || 2, this.maxZoom_ = c.maxZoom || null, this.styles_ = c.styles || [], this.title_ = c.title || &quot;&quot;, this.zoomOnClick_ = !0, void 0 !== c.zoomOnClick &amp;&amp; (this.zoomOnClick_ = c.zoomOnClick), this.averageCenter_ = !1, void 0 !== c.averageCenter &amp;&amp; (this.averageCenter_ = c.averageCenter), this.ignoreHidden_ = !1, void 0 !== c.ignoreHidden &amp;&amp; (this.ignoreHidden_ = c.ignoreHidden), this.enableRetinaIcons_ = !1, void 0 !== c.enableRetinaIcons &amp;&amp; (this.enableRetinaIcons_ = c.enableRetinaIcons), this.imagePath_ = c.imagePath || MarkerClusterer.IMAGE_PATH, this.imageExtension_ = c.imageExtension || MarkerClusterer.IMAGE_EXTENSION, this.imageSizes_ = c.imageSizes || MarkerClusterer.IMAGE_SIZES, this.calculator_ = c.calculator || MarkerClusterer.CALCULATOR, this.batchSize_ = c.batchSize || MarkerClusterer.BATCH_SIZE, this.batchSizeIE_ = c.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE, this.clusterClass_ = c.clusterClass || &quot;cluster&quot;, -1 !== navigator.userAgent.toLowerCase().indexOf(&quot;msie&quot;) &amp;&amp; (this.batchSize_ = this.batchSizeIE_), this.setupStyles_(), this.addMarkers(b, !0), this.setMap(a)
}
function inherits(a, b) {
	function c() {
	}

	c.prototype = b.prototype, a.superClass_ = b.prototype, a.prototype = new c, a.prototype.constructor = a
}
function MarkerLabel_(a, b) {
	this.marker_ = a, this.handCursorURL_ = a.handCursorURL, this.labelDiv_ = document.createElement(&quot;div&quot;), this.labelDiv_.style.cssText = &quot;position: absolute; overflow: hidden;&quot;, this.eventDiv_ = document.createElement(&quot;div&quot;), this.eventDiv_.style.cssText = this.labelDiv_.style.cssText, this.eventDiv_.setAttribute(&quot;onselectstart&quot;, &quot;return false;&quot;), this.eventDiv_.setAttribute(&quot;ondragstart&quot;, &quot;return false;&quot;), this.crossDiv_ = MarkerLabel_.getSharedCross(b)
}
function MarkerWithLabel(a) {
	a = a || {}, a.labelContent = a.labelContent || &quot;&quot;, a.labelAnchor = a.labelAnchor || new google.maps.Point(0, 0), a.labelClass = a.labelClass || &quot;markerLabels&quot;, a.labelStyle = a.labelStyle || {}, a.labelInBackground = a.labelInBackground || !1, &quot;undefined&quot; == typeof a.labelVisible &amp;&amp; (a.labelVisible = !0), &quot;undefined&quot; == typeof a.raiseOnDrag &amp;&amp; (a.raiseOnDrag = !0), &quot;undefined&quot; == typeof a.clickable &amp;&amp; (a.clickable = !0), &quot;undefined&quot; == typeof a.draggable &amp;&amp; (a.draggable = !1), &quot;undefined&quot; == typeof a.optimized &amp;&amp; (a.optimized = !1), a.crossImage = a.crossImage || &quot;http&quot; + (&quot;https:&quot; === document.location.protocol ? &quot;s&quot; : &quot;&quot;) + &quot;://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png&quot;, a.handCursor = a.handCursor || &quot;http&quot; + (&quot;https:&quot; === document.location.protocol ? &quot;s&quot; : &quot;&quot;) + &quot;://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur&quot;, a.optimized = !1, this.label = new MarkerLabel_(this, a.crossImage, a.handCursor), google.maps.Marker.apply(this, arguments)
}
InfoBox.prototype = new google.maps.OverlayView, InfoBox.prototype.createInfoBoxDiv_ = function () {
	var a, b, c, d = this, e = function (a) {
		a.cancelBubble = !0, a.stopPropagation &amp;&amp; a.stopPropagation()
	}, f = function (a) {
		a.returnValue = !1, a.preventDefault &amp;&amp; a.preventDefault(), d.enableEventPropagation_ || e(a)
	};
	if (!this.div_) {
		if (this.div_ = document.createElement(&quot;div&quot;), this.setBoxStyle_(), &quot;undefined&quot; == typeof this.content_.nodeType ? this.div_.innerHTML = this.getCloseBoxImg_() + this.content_ : (this.div_.innerHTML = this.getCloseBoxImg_(), this.div_.appendChild(this.content_)), this.getPanes()[this.pane_].appendChild(this.div_), this.addClickHandler_(), this.div_.style.width ? this.fixedWidthSet_ = !0 : 0 !== this.maxWidth_ &amp;&amp; this.div_.offsetWidth &gt; this.maxWidth_ ? (this.div_.style.width = this.maxWidth_, this.div_.style.overflow = &quot;auto&quot;, this.fixedWidthSet_ = !0) : (c = this.getBoxWidths_(), this.div_.style.width = this.div_.offsetWidth - c.left - c.right + &quot;px&quot;, this.fixedWidthSet_ = !1), this.panBox_(this.disableAutoPan_), !this.enableEventPropagation_) {
			for (this.eventListeners_ = [], b = [&quot;mousedown&quot;, &quot;mouseover&quot;, &quot;mouseout&quot;, &quot;mouseup&quot;, &quot;click&quot;, &quot;dblclick&quot;, &quot;touchstart&quot;, &quot;touchend&quot;, &quot;touchmove&quot;], a = 0; a &lt; b.length; a++)this.eventListeners_.push(google.maps.event.addDomListener(this.div_, b[a], e));
			this.eventListeners_.push(google.maps.event.addDomListener(this.div_, &quot;mouseover&quot;, function () {
				this.style.cursor = &quot;default&quot;
			}))
		}
		this.contextListener_ = google.maps.event.addDomListener(this.div_, &quot;contextmenu&quot;, f), google.maps.event.trigger(this, &quot;domready&quot;)
	}
}, InfoBox.prototype.getCloseBoxImg_ = function () {
	var a = &quot;&quot;;
	return &quot;&quot; !== this.closeBoxURL_ &amp;&amp; (a = &quot;&lt;img&quot;, a += &quot; src=&#039;&quot; + this.closeBoxURL_ + &quot;&#039;&quot;, a += &quot; align=right&quot;, a += &quot; style=&#039;&quot;, a += &quot; position: relative;&quot;, a += &quot; cursor: pointer;&quot;, a += &quot; margin: &quot; + this.closeBoxMargin_ + &quot;;&quot;, a += &quot;&#039;&gt;&quot;), a
}, InfoBox.prototype.addClickHandler_ = function () {
	var a;
	&quot;&quot; !== this.closeBoxURL_ ? (a = this.div_.firstChild, this.closeListener_ = google.maps.event.addDomListener(a, &quot;click&quot;, this.getCloseClickHandler_())) : this.closeListener_ = null
}, InfoBox.prototype.getCloseClickHandler_ = function () {
	var a = this;
	return function (b) {
		b.cancelBubble = !0, b.stopPropagation &amp;&amp; b.stopPropagation(), google.maps.event.trigger(a, &quot;closeclick&quot;), a.close()
	}
}, InfoBox.prototype.panBox_ = function (a) {
	var b, c, d = 0, e = 0;
	if (!a &amp;&amp; (b = this.getMap(), b instanceof google.maps.Map)) {
		b.getBounds().contains(this.position_) || b.setCenter(this.position_), c = b.getBounds();
		var f = b.getDiv(), g = f.offsetWidth, h = f.offsetHeight, i = this.pixelOffset_.width, j = this.pixelOffset_.height, k = this.div_.offsetWidth, l = this.div_.offsetHeight, m = this.infoBoxClearance_.width, n = this.infoBoxClearance_.height, o = this.getProjection().fromLatLngToContainerPixel(this.position_);
		if (o.x &lt; -i + m ? d = o.x + i - m : o.x + k + i + m &gt; g &amp;&amp; (d = o.x + k + i + m - g), this.alignBottom_ ? o.y &lt; -j + n + l ? e = o.y + j - n - l : o.y + j + n &gt; h &amp;&amp; (e = o.y + j + n - h) : o.y &lt; -j + n ? e = o.y + j - n : o.y + l + j + n &gt; h &amp;&amp; (e = o.y + l + j + n - h), 0 !== d || 0 !== e) {
			{
				b.getCenter()
			}
			b.panBy(d, e)
		}
	}
}, InfoBox.prototype.setBoxStyle_ = function () {
	var a, b;
	if (this.div_) {
		this.div_.className = this.boxClass_, this.div_.style.cssText = &quot;&quot;, b = this.boxStyle_;
		for (a in b)b.hasOwnProperty(a) &amp;&amp; (this.div_.style[a] = b[a]);
		&quot;undefined&quot; != typeof this.div_.style.opacity &amp;&amp; &quot;&quot; !== this.div_.style.opacity &amp;&amp; (this.div_.style.filter = &quot;alpha(opacity=&quot; + 100 * this.div_.style.opacity + &quot;)&quot;), this.div_.style.position = &quot;absolute&quot;, this.div_.style.visibility = &quot;hidden&quot;, null !== this.zIndex_ &amp;&amp; (this.div_.style.zIndex = this.zIndex_)
	}
}, InfoBox.prototype.getBoxWidths_ = function () {
	var a, b = {top: 0, bottom: 0, left: 0, right: 0}, c = this.div_;
	return document.defaultView &amp;&amp; document.defaultView.getComputedStyle ? (a = c.ownerDocument.defaultView.getComputedStyle(c, &quot;&quot;), a &amp;&amp; (b.top = parseInt(a.borderTopWidth, 10) || 0, b.bottom = parseInt(a.borderBottomWidth, 10) || 0, b.left = parseInt(a.borderLeftWidth, 10) || 0, b.right = parseInt(a.borderRightWidth, 10) || 0)) : document.documentElement.currentStyle &amp;&amp; c.currentStyle &amp;&amp; (b.top = parseInt(c.currentStyle.borderTopWidth, 10) || 0, b.bottom = parseInt(c.currentStyle.borderBottomWidth, 10) || 0, b.left = parseInt(c.currentStyle.borderLeftWidth, 10) || 0, b.right = parseInt(c.currentStyle.borderRightWidth, 10) || 0), b
}, InfoBox.prototype.onRemove = function () {
	this.div_ &amp;&amp; (this.div_.parentNode.removeChild(this.div_), this.div_ = null)
}, InfoBox.prototype.draw = function () {
	this.createInfoBoxDiv_();
	var a = this.getProjection().fromLatLngToDivPixel(this.position_);
	this.div_.style.left = a.x + this.pixelOffset_.width + &quot;px&quot;, this.alignBottom_ ? this.div_.style.bottom = -(a.y + this.pixelOffset_.height) + &quot;px&quot; : this.div_.style.top = a.y + this.pixelOffset_.height + &quot;px&quot;, this.div_.style.visibility = this.isHidden_ ? &quot;hidden&quot; : &quot;visible&quot;
}, InfoBox.prototype.setOptions = function (a) {
	&quot;undefined&quot; != typeof a.boxClass &amp;&amp; (this.boxClass_ = a.boxClass, this.setBoxStyle_()), &quot;undefined&quot; != typeof a.boxStyle &amp;&amp; (this.boxStyle_ = a.boxStyle, this.setBoxStyle_()), &quot;undefined&quot; != typeof a.content &amp;&amp; this.setContent(a.content), &quot;undefined&quot; != typeof a.disableAutoPan &amp;&amp; (this.disableAutoPan_ = a.disableAutoPan), &quot;undefined&quot; != typeof a.maxWidth &amp;&amp; (this.maxWidth_ = a.maxWidth), &quot;undefined&quot; != typeof a.pixelOffset &amp;&amp; (this.pixelOffset_ = a.pixelOffset), &quot;undefined&quot; != typeof a.alignBottom &amp;&amp; (this.alignBottom_ = a.alignBottom), &quot;undefined&quot; != typeof a.position &amp;&amp; this.setPosition(a.position), &quot;undefined&quot; != typeof a.zIndex &amp;&amp; this.setZIndex(a.zIndex), &quot;undefined&quot; != typeof a.closeBoxMargin &amp;&amp; (this.closeBoxMargin_ = a.closeBoxMargin), &quot;undefined&quot; != typeof a.closeBoxURL &amp;&amp; (this.closeBoxURL_ = a.closeBoxURL), &quot;undefined&quot; != typeof a.infoBoxClearance &amp;&amp; (this.infoBoxClearance_ = a.infoBoxClearance), &quot;undefined&quot; != typeof a.isHidden &amp;&amp; (this.isHidden_ = a.isHidden), &quot;undefined&quot; != typeof a.visible &amp;&amp; (this.isHidden_ = !a.visible), &quot;undefined&quot; != typeof a.enableEventPropagation &amp;&amp; (this.enableEventPropagation_ = a.enableEventPropagation), this.div_ &amp;&amp; this.draw()
}, InfoBox.prototype.setContent = function (a) {
	this.content_ = a, this.div_ &amp;&amp; (this.closeListener_ &amp;&amp; (google.maps.event.removeListener(this.closeListener_), this.closeListener_ = null), this.fixedWidthSet_ || (this.div_.style.width = &quot;&quot;), &quot;undefined&quot; == typeof a.nodeType ? this.div_.innerHTML = this.getCloseBoxImg_() + a : (this.div_.innerHTML = this.getCloseBoxImg_(), this.div_.appendChild(a)), this.fixedWidthSet_ || (this.div_.style.width = this.div_.offsetWidth + &quot;px&quot;, &quot;undefined&quot; == typeof a.nodeType ? this.div_.innerHTML = this.getCloseBoxImg_() + a : (this.div_.innerHTML = this.getCloseBoxImg_(), this.div_.appendChild(a))), this.addClickHandler_()), google.maps.event.trigger(this, &quot;content_changed&quot;)
}, InfoBox.prototype.setPosition = function (a) {
	this.position_ = a, this.div_ &amp;&amp; this.draw(), google.maps.event.trigger(this, &quot;position_changed&quot;)
}, InfoBox.prototype.setZIndex = function (a) {
	this.zIndex_ = a, this.div_ &amp;&amp; (this.div_.style.zIndex = a), google.maps.event.trigger(this, &quot;zindex_changed&quot;)
}, InfoBox.prototype.setVisible = function (a) {
	this.isHidden_ = !a, this.div_ &amp;&amp; (this.div_.style.visibility = this.isHidden_ ? &quot;hidden&quot; : &quot;visible&quot;)
}, InfoBox.prototype.getContent = function () {
	return this.content_
}, InfoBox.prototype.getPosition = function () {
	return this.position_
}, InfoBox.prototype.getZIndex = function () {
	return this.zIndex_
}, InfoBox.prototype.getVisible = function () {
	var a;
	return a = &quot;undefined&quot; == typeof this.getMap() || null === this.getMap() ? !1 : !this.isHidden_
}, InfoBox.prototype.show = function () {
	this.isHidden_ = !1, this.div_ &amp;&amp; (this.div_.style.visibility = &quot;visible&quot;)
}, InfoBox.prototype.hide = function () {
	this.isHidden_ = !0, this.div_ &amp;&amp; (this.div_.style.visibility = &quot;hidden&quot;)
}, InfoBox.prototype.open = function (a, b) {
	var c = this;
	b &amp;&amp; (this.position_ = b.getPosition(), this.moveListener_ = google.maps.event.addListener(b, &quot;position_changed&quot;, function () {
		c.setPosition(this.getPosition())
	})), this.setMap(a), this.div_ &amp;&amp; this.panBox_()
}, InfoBox.prototype.close = function () {
	var a;
	if (this.closeListener_ &amp;&amp; (google.maps.event.removeListener(this.closeListener_), this.closeListener_ = null), this.eventListeners_) {
		for (a = 0; a &lt; this.eventListeners_.length; a++)google.maps.event.removeListener(this.eventListeners_[a]);
		this.eventListeners_ = null
	}
	this.moveListener_ &amp;&amp; (google.maps.event.removeListener(this.moveListener_), this.moveListener_ = null), this.contextListener_ &amp;&amp; (google.maps.event.removeListener(this.contextListener_), this.contextListener_ = null), this.setMap(null)
}, ClusterIcon.prototype.onAdd = function () {
	var a, b, c = this;
	this.div_ = document.createElement(&quot;div&quot;), this.div_.className = this.className_, this.visible_ &amp;&amp; this.show(), this.getPanes().overlayMouseTarget.appendChild(this.div_), this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), &quot;bounds_changed&quot;, function () {
		b = a
	}), google.maps.event.addDomListener(this.div_, &quot;mousedown&quot;, function () {
		a = !0, b = !1
	}), google.maps.event.addDomListener(this.div_, &quot;click&quot;, function (d) {
		if (a = !1, !b) {
			var e, f, g = c.cluster_.getMarkerClusterer();
			google.maps.event.trigger(g, &quot;click&quot;, c.cluster_), google.maps.event.trigger(g, &quot;clusterclick&quot;, c.cluster_), g.getZoomOnClick() &amp;&amp; (f = g.getMaxZoom(), e = c.cluster_.getBounds(), g.getMap().fitBounds(e), setTimeout(function () {
				g.getMap().fitBounds(e), null !== f &amp;&amp; g.getMap().getZoom() &gt; f &amp;&amp; g.getMap().setZoom(f + 1)
			}, 100)), d.cancelBubble = !0, d.stopPropagation &amp;&amp; d.stopPropagation()
		}
	}), google.maps.event.addDomListener(this.div_, &quot;mouseover&quot;, function () {
		var a = c.cluster_.getMarkerClusterer();
		google.maps.event.trigger(a, &quot;mouseover&quot;, c.cluster_)
	}), google.maps.event.addDomListener(this.div_, &quot;mouseout&quot;, function () {
		var a = c.cluster_.getMarkerClusterer();
		google.maps.event.trigger(a, &quot;mouseout&quot;, c.cluster_)
	})
}, ClusterIcon.prototype.onRemove = function () {
	this.div_ &amp;&amp; this.div_.parentNode &amp;&amp; (this.hide(), google.maps.event.removeListener(this.boundsChangedListener_), google.maps.event.clearInstanceListeners(this.div_), this.div_.parentNode.removeChild(this.div_), this.div_ = null)
}, ClusterIcon.prototype.draw = function () {
	if (this.visible_) {
		var a = this.getPosFromLatLng_(this.center_);
		this.div_.style.top = a.y + &quot;px&quot;, this.div_.style.left = a.x + &quot;px&quot;
	}
}, ClusterIcon.prototype.hide = function () {
	this.div_ &amp;&amp; (this.div_.style.display = &quot;none&quot;), this.visible_ = !1
}, ClusterIcon.prototype.show = function () {
	if (this.div_) {
		var a = &quot;&quot;, b = this.backgroundPosition_.split(&quot; &quot;), c = parseInt(b[0].trim(), 10), d = parseInt(b[1].trim(), 10), e = this.getPosFromLatLng_(this.center_);
		this.div_.style.cssText = this.createCss(e), a = &quot;&lt;img src=&#039;&quot; + this.url_ + &quot;&#039; style=&#039;position: absolute; top: &quot; + d + &quot;px; left: &quot; + c + &quot;px; &quot;, this.cluster_.getMarkerClusterer().enableRetinaIcons_ || (a += &quot;clip: rect(&quot; + -1 * d + &quot;px, &quot; + (-1 * c + this.width_) + &quot;px, &quot; + (-1 * d + this.height_) + &quot;px, &quot; + -1 * c + &quot;px);&quot;), a += &quot;&#039;&gt;&quot;, this.div_.innerHTML = a + &quot;&lt;div style=&#039;position: absolute;top: &quot; + this.anchorText_[0] + &quot;px;left: &quot; + this.anchorText_[1] + &quot;px;color: &quot; + this.textColor_ + &quot;;font-size: &quot; + this.textSize_ + &quot;px;font-family: &quot; + this.fontFamily_ + &quot;;font-weight: &quot; + this.fontWeight_ + &quot;;font-style: &quot; + this.fontStyle_ + &quot;;text-decoration: &quot; + this.textDecoration_ + &quot;;text-align: center;width: &quot; + this.width_ + &quot;px;line-height:&quot; + this.height_ + &quot;px;&#039;&gt;&quot; + this.sums_.text + &quot;&lt;/div&gt;&quot;, this.div_.title = &quot;undefined&quot; == typeof this.sums_.title || &quot;&quot; === this.sums_.title ? this.cluster_.getMarkerClusterer().getTitle() : this.sums_.title, this.div_.style.display = &quot;&quot;
	}
	this.visible_ = !0
}, ClusterIcon.prototype.useStyle = function (a) {
	this.sums_ = a;
	var b = Math.max(0, a.index - 1);
	b = Math.min(this.styles_.length - 1, b);
	var c = this.styles_[b];
	this.url_ = c.url, this.height_ = c.height, this.width_ = c.width, this.anchorText_ = c.anchorText || [0, 0], this.anchorIcon_ = c.anchorIcon || [parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10)], this.textColor_ = c.textColor || &quot;black&quot;, this.textSize_ = c.textSize || 11, this.textDecoration_ = c.textDecoration || &quot;none&quot;, this.fontWeight_ = c.fontWeight || &quot;bold&quot;, this.fontStyle_ = c.fontStyle || &quot;normal&quot;, this.fontFamily_ = c.fontFamily || &quot;Arial,sans-serif&quot;, this.backgroundPosition_ = c.backgroundPosition || &quot;0 0&quot;
}, ClusterIcon.prototype.setCenter = function (a) {
	this.center_ = a
}, ClusterIcon.prototype.createCss = function (a) {
	var b = [];
	return b.push(&quot;cursor: pointer;&quot;), b.push(&quot;position: absolute; top: &quot; + a.y + &quot;px; left: &quot; + a.x + &quot;px;&quot;), b.push(&quot;width: &quot; + this.width_ + &quot;px; height: &quot; + this.height_ + &quot;px;&quot;), b.join(&quot;&quot;)
}, ClusterIcon.prototype.getPosFromLatLng_ = function (a) {
	var b = this.getProjection().fromLatLngToDivPixel(a);
	return b.x -= this.anchorIcon_[1], b.y -= this.anchorIcon_[0], b.x = parseInt(b.x, 10), b.y = parseInt(b.y, 10), b
}, Cluster.prototype.getSize = function () {
	return this.markers_.length
}, Cluster.prototype.getMarkers = function () {
	return this.markers_
}, Cluster.prototype.getCenter = function () {
	return this.center_
}, Cluster.prototype.getMap = function () {
	return this.map_
}, Cluster.prototype.getMarkerClusterer = function () {
	return this.markerClusterer_
}, Cluster.prototype.getBounds = function () {
	var a, b = new google.maps.LatLngBounds(this.center_, this.center_), c = this.getMarkers();
	for (a = 0; a &lt; c.length; a++)b.extend(c[a].getPosition());
	return b
}, Cluster.prototype.remove = function () {
	this.clusterIcon_.setMap(null), this.markers_ = [], delete this.markers_
}, Cluster.prototype.addMarker = function (a) {
	var b, c, d;
	if (this.isMarkerAlreadyAdded_(a))return !1;
	if (this.center_) {
		if (this.averageCenter_) {
			var e = this.markers_.length + 1, f = (this.center_.lat() * (e - 1) + a.getPosition().lat()) / e, g = (this.center_.lng() * (e - 1) + a.getPosition().lng()) / e;
			this.center_ = new google.maps.LatLng(f, g), this.calculateBounds_()
		}
	} else this.center_ = a.getPosition(), this.calculateBounds_();
	if (a.isAdded = !0, this.markers_.push(a), c = this.markers_.length, d = this.markerClusterer_.getMaxZoom(), null !== d &amp;&amp; this.map_.getZoom() &gt; d)a.getMap() !== this.map_ &amp;&amp; a.setMap(this.map_); else if (c &lt; this.minClusterSize_)a.getMap() !== this.map_ &amp;&amp; a.setMap(this.map_); else if (c === this.minClusterSize_)for (b = 0; c &gt; b; b++)this.markers_[b].setMap(null); else a.setMap(null);
	return this.updateIcon_(), !0
}, Cluster.prototype.isMarkerInClusterBounds = function (a) {
	return this.bounds_.contains(a.getPosition())
}, Cluster.prototype.calculateBounds_ = function () {
	var a = new google.maps.LatLngBounds(this.center_, this.center_);
	this.bounds_ = this.markerClusterer_.getExtendedBounds(a)
}, Cluster.prototype.updateIcon_ = function () {
	var a = this.markers_.length, b = this.markerClusterer_.getMaxZoom();
	if (null !== b &amp;&amp; this.map_.getZoom() &gt; b)return void this.clusterIcon_.hide();
	if (a &lt; this.minClusterSize_)return void this.clusterIcon_.hide();
	var c = this.markerClusterer_.getStyles().length, d = this.markerClusterer_.getCalculator()(this.markers_, c);
	this.clusterIcon_.setCenter(this.center_), this.clusterIcon_.useStyle(d), this.clusterIcon_.show()
}, Cluster.prototype.isMarkerAlreadyAdded_ = function (a) {
	var b;
	if (this.markers_.indexOf)return -1 !== this.markers_.indexOf(a);
	for (b = 0; b &lt; this.markers_.length; b++)if (a === this.markers_[b])return !0;
	return !1
}, MarkerClusterer.prototype.onAdd = function () {
	var a = this;
	this.activeMap_ = this.getMap(), this.ready_ = !0, this.repaint(), this.listeners_ = [google.maps.event.addListener(this.getMap(), &quot;zoom_changed&quot;, function () {
		a.resetViewport_(!1), (this.getZoom() === (this.get(&quot;minZoom&quot;) || 0) || this.getZoom() === this.get(&quot;maxZoom&quot;)) &amp;&amp; google.maps.event.trigger(this, &quot;idle&quot;)
	}), google.maps.event.addListener(this.getMap(), &quot;idle&quot;, function () {
		a.redraw_()
	})]
}, MarkerClusterer.prototype.onRemove = function () {
	var a;
	for (a = 0; a &lt; this.markers_.length; a++)this.markers_[a].getMap() !== this.activeMap_ &amp;&amp; this.markers_[a].setMap(this.activeMap_);
	for (a = 0; a &lt; this.clusters_.length; a++)this.clusters_[a].remove();
	for (this.clusters_ = [], a = 0; a &lt; this.listeners_.length; a++)google.maps.event.removeListener(this.listeners_[a]);
	this.listeners_ = [], this.activeMap_ = null, this.ready_ = !1
}, MarkerClusterer.prototype.draw = function () {
}, MarkerClusterer.prototype.setupStyles_ = function () {
	var a, b;
	if (!(this.styles_.length &gt; 0))for (a = 0; a &lt; this.imageSizes_.length; a++)b = this.imageSizes_[a], this.styles_.push({
		url: this.imagePath_ + (a + 1) + &quot;.&quot; + this.imageExtension_,
		height: b,
		width: b
	})
}, MarkerClusterer.prototype.fitMapToMarkers = function () {
	var a, b = this.getMarkers(), c = new google.maps.LatLngBounds;
	for (a = 0; a &lt; b.length; a++)c.extend(b[a].getPosition());
	this.getMap().fitBounds(c)
}, MarkerClusterer.prototype.getGridSize = function () {
	return this.gridSize_
}, MarkerClusterer.prototype.setGridSize = function (a) {
	this.gridSize_ = a
}, MarkerClusterer.prototype.getMinimumClusterSize = function () {
	return this.minClusterSize_
}, MarkerClusterer.prototype.setMinimumClusterSize = function (a) {
	this.minClusterSize_ = a
}, MarkerClusterer.prototype.getMaxZoom = function () {
	return this.maxZoom_
}, MarkerClusterer.prototype.setMaxZoom = function (a) {
	this.maxZoom_ = a
}, MarkerClusterer.prototype.getStyles = function () {
	return this.styles_
}, MarkerClusterer.prototype.setStyles = function (a) {
	this.styles_ = a
}, MarkerClusterer.prototype.getTitle = function () {
	return this.title_
}, MarkerClusterer.prototype.setTitle = function (a) {
	this.title_ = a
}, MarkerClusterer.prototype.getZoomOnClick = function () {
	return this.zoomOnClick_
}, MarkerClusterer.prototype.setZoomOnClick = function (a) {
	this.zoomOnClick_ = a
}, MarkerClusterer.prototype.getAverageCenter = function () {
	return this.averageCenter_
}, MarkerClusterer.prototype.setAverageCenter = function (a) {
	this.averageCenter_ = a
}, MarkerClusterer.prototype.getIgnoreHidden = function () {
	return this.ignoreHidden_
}, MarkerClusterer.prototype.setIgnoreHidden = function (a) {
	this.ignoreHidden_ = a
}, MarkerClusterer.prototype.getEnableRetinaIcons = function () {
	return this.enableRetinaIcons_
}, MarkerClusterer.prototype.setEnableRetinaIcons = function (a) {
	this.enableRetinaIcons_ = a
}, MarkerClusterer.prototype.getImageExtension = function () {
	return this.imageExtension_
}, MarkerClusterer.prototype.setImageExtension = function (a) {
	this.imageExtension_ = a
}, MarkerClusterer.prototype.getImagePath = function () {
	return this.imagePath_
}, MarkerClusterer.prototype.setImagePath = function (a) {
	this.imagePath_ = a
}, MarkerClusterer.prototype.getImageSizes = function () {
	return this.imageSizes_
}, MarkerClusterer.prototype.setImageSizes = function (a) {
	this.imageSizes_ = a
}, MarkerClusterer.prototype.getCalculator = function () {
	return this.calculator_
}, MarkerClusterer.prototype.setCalculator = function (a) {
	this.calculator_ = a
}, MarkerClusterer.prototype.getBatchSizeIE = function () {
	return this.batchSizeIE_
}, MarkerClusterer.prototype.setBatchSizeIE = function (a) {
	this.batchSizeIE_ = a
}, MarkerClusterer.prototype.getClusterClass = function () {
	return this.clusterClass_
}, MarkerClusterer.prototype.setClusterClass = function (a) {
	this.clusterClass_ = a
}, MarkerClusterer.prototype.getMarkers = function () {
	return this.markers_
}, MarkerClusterer.prototype.getTotalMarkers = function () {
	return this.markers_.length
}, MarkerClusterer.prototype.getClusters = function () {
	return this.clusters_
}, MarkerClusterer.prototype.getTotalClusters = function () {
	return this.clusters_.length
}, MarkerClusterer.prototype.addMarker = function (a, b) {
	this.pushMarkerTo_(a), b || this.redraw_()
}, MarkerClusterer.prototype.addMarkers = function (a, b) {
	var c;
	for (c in a)a.hasOwnProperty(c) &amp;&amp; this.pushMarkerTo_(a[c]);
	b || this.redraw_()
}, MarkerClusterer.prototype.pushMarkerTo_ = function (a) {
	if (a.getDraggable()) {
		var b = this;
		google.maps.event.addListener(a, &quot;dragend&quot;, function () {
			b.ready_ &amp;&amp; (this.isAdded = !1, b.repaint())
		})
	}
	a.isAdded = !1, this.markers_.push(a)
}, MarkerClusterer.prototype.removeMarker = function (a, b) {
	var c = this.removeMarker_(a);
	return !b &amp;&amp; c &amp;&amp; this.repaint(), c
}, MarkerClusterer.prototype.removeMarkers = function (a, b) {
	var c, d, e = !1;
	for (c = 0; c &lt; a.length; c++)d = this.removeMarker_(a[c]), e = e || d;
	return !b &amp;&amp; e &amp;&amp; this.repaint(), e
}, MarkerClusterer.prototype.removeMarker_ = function (a) {
	var b, c = -1;
	if (this.markers_.indexOf)c = this.markers_.indexOf(a); else for (b = 0; b &lt; this.markers_.length; b++)if (a === this.markers_[b]) {
		c = b;
		break
	}
	return -1 === c ? !1 : (a.setMap(null), this.markers_.splice(c, 1), !0)
}, MarkerClusterer.prototype.clearMarkers = function () {
	this.resetViewport_(!0), this.markers_ = []
}, MarkerClusterer.prototype.repaint = function () {
	var a = this.clusters_.slice();
	this.clusters_ = [], this.resetViewport_(!1), this.redraw_(), setTimeout(function () {
		var b;
		for (b = 0; b &lt; a.length; b++)a[b].remove()
	}, 0)
}, MarkerClusterer.prototype.getExtendedBounds = function (a) {
	var b = this.getProjection(), c = new google.maps.LatLng(a.getNorthEast().lat(), a.getNorthEast().lng()), d = new google.maps.LatLng(a.getSouthWest().lat(), a.getSouthWest().lng()), e = b.fromLatLngToDivPixel(c);
	e.x += this.gridSize_, e.y -= this.gridSize_;
	var f = b.fromLatLngToDivPixel(d);
	f.x -= this.gridSize_, f.y += this.gridSize_;
	var g = b.fromDivPixelToLatLng(e), h = b.fromDivPixelToLatLng(f);
	return a.extend(g), a.extend(h), a
}, MarkerClusterer.prototype.redraw_ = function () {
	this.createClusters_(0)
}, MarkerClusterer.prototype.resetViewport_ = function (a) {
	var b, c;
	for (b = 0; b &lt; this.clusters_.length; b++)this.clusters_[b].remove();
	for (this.clusters_ = [], b = 0; b &lt; this.markers_.length; b++)c = this.markers_[b], c.isAdded = !1, a &amp;&amp; c.setMap(null)
}, MarkerClusterer.prototype.distanceBetweenPoints_ = function (a, b) {
	var c = 6371, d = (b.lat() - a.lat()) * Math.PI / 180, e = (b.lng() - a.lng()) * Math.PI / 180, f = Math.sin(d / 2) * Math.sin(d / 2) + Math.cos(a.lat() * Math.PI / 180) * Math.cos(b.lat() * Math.PI / 180) * Math.sin(e / 2) * Math.sin(e / 2), g = 2 * Math.atan2(Math.sqrt(f), Math.sqrt(1 - f)), h = c * g;
	return h
}, MarkerClusterer.prototype.isMarkerInBounds_ = function (a, b) {
	return b.contains(a.getPosition())
}, MarkerClusterer.prototype.addToClosestCluster_ = function (a) {
	var b, c, d, e, f = 4e4, g = null;
	for (b = 0; b &lt; this.clusters_.length; b++)d = this.clusters_[b], e = d.getCenter(), e &amp;&amp; (c = this.distanceBetweenPoints_(e, a.getPosition()), f &gt; c &amp;&amp; (f = c, g = d));
	g &amp;&amp; g.isMarkerInClusterBounds(a) ? g.addMarker(a) : (d = new Cluster(this), d.addMarker(a), this.clusters_.push(d))
}, MarkerClusterer.prototype.createClusters_ = function (a) {
	var b, c, d, e = this;
	if (this.ready_) {
		0 === a &amp;&amp; (google.maps.event.trigger(this, &quot;clusteringbegin&quot;, this), &quot;undefined&quot; != typeof this.timerRefStatic &amp;&amp; (clearTimeout(this.timerRefStatic), delete this.timerRefStatic)), d = this.getMap().getZoom() &gt; 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
		var f = this.getExtendedBounds(d), g = Math.min(a + this.batchSize_, this.markers_.length);
		for (b = a; g &gt; b; b++)c = this.markers_[b], !c.isAdded &amp;&amp; this.isMarkerInBounds_(c, f) &amp;&amp; (!this.ignoreHidden_ || this.ignoreHidden_ &amp;&amp; c.getVisible()) &amp;&amp; this.addToClosestCluster_(c);
		g &lt; this.markers_.length ? this.timerRefStatic = setTimeout(function () {
			e.createClusters_(g)
		}, 0) : (delete this.timerRefStatic, google.maps.event.trigger(this, &quot;clusteringend&quot;, this))
	}
}, MarkerClusterer.prototype.extend = function (a, b) {
	return function (a) {
		var b;
		for (b in a.prototype)this.prototype[b] = a.prototype[b];
		return this
	}.apply(a, [b])
}, MarkerClusterer.CALCULATOR = function (a, b) {
	for (var c = 0, d = &quot;&quot;, e = a.length.toString(), f = e; 0 !== f;)f = parseInt(f / 10, 10), c++;
	return c = Math.min(c, b), {text: e, index: c, title: d}
}, MarkerClusterer.BATCH_SIZE = 2e3,MarkerClusterer.BATCH_SIZE_IE = 500,MarkerClusterer.IMAGE_PATH = &quot;http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m&quot;,MarkerClusterer.IMAGE_EXTENSION = &quot;png&quot;,MarkerClusterer.IMAGE_SIZES = [53, 56, 66, 78, 90],&quot;function&quot; != typeof String.prototype.trim &amp;&amp; (String.prototype.trim = function () {
	return this.replace(/^\s+|\s+$/g, &quot;&quot;)
}),inherits(MarkerLabel_, google.maps.OverlayView),MarkerLabel_.getSharedCross = function (a) {
	var b;
	return &quot;undefined&quot; == typeof MarkerLabel_.getSharedCross.crossDiv &amp;&amp; (b = document.createElement(&quot;img&quot;), b.style.cssText = &quot;position: absolute; z-index: 1000002; display: none;&quot;, b.style.marginLeft = &quot;-8px&quot;, b.style.marginTop = &quot;-9px&quot;, b.src = a, MarkerLabel_.getSharedCross.crossDiv = b), MarkerLabel_.getSharedCross.crossDiv
},MarkerLabel_.prototype.onAdd = function () {
	var a, b, c, d, e, f, g, h = this, i = !1, j = !1, k = 20, l = &quot;url(&quot; + this.handCursorURL_ + &quot;)&quot;, m = function (a) {
		a.preventDefault &amp;&amp; a.preventDefault(), a.cancelBubble = !0, a.stopPropagation &amp;&amp; a.stopPropagation()
	}, n = function () {
		h.marker_.setAnimation(null)
	};
	this.getPanes().overlayImage.appendChild(this.labelDiv_), this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_), &quot;undefined&quot; == typeof MarkerLabel_.getSharedCross.processed &amp;&amp; (this.getPanes().overlayImage.appendChild(this.crossDiv_), MarkerLabel_.getSharedCross.processed = !0), this.listeners_ = [google.maps.event.addDomListener(this.eventDiv_, &quot;mouseover&quot;, function (a) {
		(h.marker_.getDraggable() || h.marker_.getClickable()) &amp;&amp; (this.style.cursor = &quot;pointer&quot;, google.maps.event.trigger(h.marker_, &quot;mouseover&quot;, a))
	}), google.maps.event.addDomListener(this.eventDiv_, &quot;mouseout&quot;, function (a) {
		!h.marker_.getDraggable() &amp;&amp; !h.marker_.getClickable() || j || (this.style.cursor = h.marker_.getCursor(), google.maps.event.trigger(h.marker_, &quot;mouseout&quot;, a))
	}), google.maps.event.addDomListener(this.eventDiv_, &quot;mousedown&quot;, function (a) {
		j = !1, h.marker_.getDraggable() &amp;&amp; (i = !0, this.style.cursor = l), (h.marker_.getDraggable() || h.marker_.getClickable()) &amp;&amp; (google.maps.event.trigger(h.marker_, &quot;mousedown&quot;, a), m(a))
	}), google.maps.event.addDomListener(document, &quot;mouseup&quot;, function (b) {
		var c;
		if (i &amp;&amp; (i = !1, h.eventDiv_.style.cursor = &quot;pointer&quot;, google.maps.event.trigger(h.marker_, &quot;mouseup&quot;, b)), j) {
			if (e) {
				c = h.getProjection().fromLatLngToDivPixel(h.marker_.getPosition()), c.y += k, h.marker_.setPosition(h.getProjection().fromDivPixelToLatLng(c));
				try {
					h.marker_.setAnimation(google.maps.Animation.BOUNCE), setTimeout(n, 1406)
				} catch (f) {
				}
			}
			h.crossDiv_.style.display = &quot;none&quot;, h.marker_.setZIndex(a), d = !0, j = !1, b.latLng = h.marker_.getPosition(), google.maps.event.trigger(h.marker_, &quot;dragend&quot;, b)
		}
	}), google.maps.event.addListener(h.marker_.getMap(), &quot;mousemove&quot;, function (d) {
		var l;
		i &amp;&amp; (j ? (d.latLng = new google.maps.LatLng(d.latLng.lat() - b, d.latLng.lng() - c), l = h.getProjection().fromLatLngToDivPixel(d.latLng), e &amp;&amp; (h.crossDiv_.style.left = l.x + &quot;px&quot;, h.crossDiv_.style.top = l.y + &quot;px&quot;, h.crossDiv_.style.display = &quot;&quot;, l.y -= k), h.marker_.setPosition(h.getProjection().fromDivPixelToLatLng(l)), e &amp;&amp; (h.eventDiv_.style.top = l.y + k + &quot;px&quot;), google.maps.event.trigger(h.marker_, &quot;drag&quot;, d)) : (b = d.latLng.lat() - h.marker_.getPosition().lat(), c = d.latLng.lng() - h.marker_.getPosition().lng(), a = h.marker_.getZIndex(), f = h.marker_.getPosition(), g = h.marker_.getMap().getCenter(), e = h.marker_.get(&quot;raiseOnDrag&quot;), j = !0, h.marker_.setZIndex(1e6), d.latLng = h.marker_.getPosition(), google.maps.event.trigger(h.marker_, &quot;dragstart&quot;, d)))
	}), google.maps.event.addDomListener(document, &quot;keydown&quot;, function (a) {
		j &amp;&amp; 27 === a.keyCode &amp;&amp; (e = !1, h.marker_.setPosition(f), h.marker_.getMap().setCenter(g), google.maps.event.trigger(document, &quot;mouseup&quot;, a))
	}), google.maps.event.addDomListener(this.eventDiv_, &quot;click&quot;, function (a) {
		(h.marker_.getDraggable() || h.marker_.getClickable()) &amp;&amp; (d ? d = !1 : (google.maps.event.trigger(h.marker_, &quot;click&quot;, a), m(a)))
	}), google.maps.event.addDomListener(this.eventDiv_, &quot;dblclick&quot;, function (a) {
		(h.marker_.getDraggable() || h.marker_.getClickable()) &amp;&amp; (google.maps.event.trigger(h.marker_, &quot;dblclick&quot;, a), m(a))
	}), google.maps.event.addListener(this.marker_, &quot;dragstart&quot;, function () {
		j || (e = this.get(&quot;raiseOnDrag&quot;))
	}), google.maps.event.addListener(this.marker_, &quot;drag&quot;, function () {
		j || e &amp;&amp; (h.setPosition(k), h.labelDiv_.style.zIndex = 1e6 + (this.get(&quot;labelInBackground&quot;) ? -1 : 1))
	}), google.maps.event.addListener(this.marker_, &quot;dragend&quot;, function () {
		j || e &amp;&amp; h.setPosition(0)
	}), google.maps.event.addListener(this.marker_, &quot;position_changed&quot;, function () {
		h.setPosition()
	}), google.maps.event.addListener(this.marker_, &quot;zindex_changed&quot;, function () {
		h.setZIndex()
	}), google.maps.event.addListener(this.marker_, &quot;visible_changed&quot;, function () {
		h.setVisible()
	}), google.maps.event.addListener(this.marker_, &quot;labelvisible_changed&quot;, function () {
		h.setVisible()
	}), google.maps.event.addListener(this.marker_, &quot;title_changed&quot;, function () {
		h.setTitle()
	}), google.maps.event.addListener(this.marker_, &quot;labelcontent_changed&quot;, function () {
		h.setContent()
	}), google.maps.event.addListener(this.marker_, &quot;labelanchor_changed&quot;, function () {
		h.setAnchor()
	}), google.maps.event.addListener(this.marker_, &quot;labelclass_changed&quot;, function () {
		h.setStyles()
	}), google.maps.event.addListener(this.marker_, &quot;labelstyle_changed&quot;, function () {
		h.setStyles()
	})]
},MarkerLabel_.prototype.onRemove = function () {
	var a;
	for (null !== this.labelDiv_.parentNode &amp;&amp; this.labelDiv_.parentNode.removeChild(this.labelDiv_), null !== this.eventDiv_.parentNode &amp;&amp; this.eventDiv_.parentNode.removeChild(this.eventDiv_), a = 0; a &lt; this.listeners_.length; a++)google.maps.event.removeListener(this.listeners_[a])
},MarkerLabel_.prototype.draw = function () {
	this.setContent(), this.setTitle(), this.setStyles()
},MarkerLabel_.prototype.setContent = function () {
	var a = this.marker_.get(&quot;labelContent&quot;);
	&quot;undefined&quot; == typeof a.nodeType ? (this.labelDiv_.innerHTML = a, this.eventDiv_.innerHTML = this.labelDiv_.innerHTML) : (this.labelDiv_.innerHTML = &quot;&quot;, this.labelDiv_.appendChild(a), a = a.cloneNode(!0), this.eventDiv_.appendChild(a))
},MarkerLabel_.prototype.setTitle = function () {
	this.eventDiv_.title = this.marker_.getTitle() || &quot;&quot;
},MarkerLabel_.prototype.setStyles = function () {
	var a, b;
	this.labelDiv_.className = this.marker_.get(&quot;labelClass&quot;), this.eventDiv_.className = this.labelDiv_.className, this.labelDiv_.style.cssText = &quot;&quot;, this.eventDiv_.style.cssText = &quot;&quot;, b = this.marker_.get(&quot;labelStyle&quot;);
	for (a in b)b.hasOwnProperty(a) &amp;&amp; (this.labelDiv_.style[a] = b[a], this.eventDiv_.style[a] = b[a]);
	this.setMandatoryStyles()
},MarkerLabel_.prototype.setMandatoryStyles = function () {
	this.labelDiv_.style.position = &quot;absolute&quot;, this.labelDiv_.style.overflow = &quot;hidden&quot;, &quot;undefined&quot; != typeof this.labelDiv_.style.opacity &amp;&amp; &quot;&quot; !== this.labelDiv_.style.opacity &amp;&amp; (this.labelDiv_.style.MsFilter = &#039;&quot;progid:DXImageTransform.Microsoft.Alpha(opacity=&#039; + 100 * this.labelDiv_.style.opacity + &#039;)&quot;&#039;, this.labelDiv_.style.filter = &quot;alpha(opacity=&quot; + 100 * this.labelDiv_.style.opacity + &quot;)&quot;), this.eventDiv_.style.position = this.labelDiv_.style.position, this.eventDiv_.style.overflow = this.labelDiv_.style.overflow, this.eventDiv_.style.opacity = .01, this.eventDiv_.style.MsFilter = &#039;&quot;progid:DXImageTransform.Microsoft.Alpha(opacity=1)&quot;&#039;, this.eventDiv_.style.filter = &quot;alpha(opacity=1)&quot;, this.setAnchor(), this.setPosition(), this.setVisible()
},MarkerLabel_.prototype.setAnchor = function () {
	var a = this.marker_.get(&quot;labelAnchor&quot;);
	this.labelDiv_.style.marginLeft = -a.x + &quot;px&quot;, this.labelDiv_.style.marginTop = -a.y + &quot;px&quot;, this.eventDiv_.style.marginLeft = -a.x + &quot;px&quot;, this.eventDiv_.style.marginTop = -a.y + &quot;px&quot;
},MarkerLabel_.prototype.setPosition = function (a) {
	var b = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
	&quot;undefined&quot; == typeof a &amp;&amp; (a = 0), this.labelDiv_.style.left = Math.round(b.x) + &quot;px&quot;, this.labelDiv_.style.top = Math.round(b.y - a) + &quot;px&quot;, this.eventDiv_.style.left = this.labelDiv_.style.left, this.eventDiv_.style.top = this.labelDiv_.style.top, this.setZIndex()
},MarkerLabel_.prototype.setZIndex = function () {
	var a = this.marker_.get(&quot;labelInBackground&quot;) ? -1 : 1;
	&quot;undefined&quot; == typeof this.marker_.getZIndex() ? (this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + a, this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex) : (this.labelDiv_.style.zIndex = this.marker_.getZIndex() + a, this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex)
},MarkerLabel_.prototype.setVisible = function () {
	this.labelDiv_.style.display = this.marker_.get(&quot;labelVisible&quot;) &amp;&amp; this.marker_.getVisible() ? &quot;block&quot; : &quot;none&quot;, this.eventDiv_.style.display = this.labelDiv_.style.display
},inherits(MarkerWithLabel, google.maps.Marker),MarkerWithLabel.prototype.setMap = function (a) {
	google.maps.Marker.prototype.setMap.apply(this, arguments), this.label.setMap(a)
},function () {
	angular.module(&quot;google-maps.wrapped&quot;, []), angular.module(&quot;google-maps.extensions&quot;, [&quot;google-maps.wrapped&quot;]), angular.module(&quot;google-maps.directives.api.utils&quot;, [&quot;google-maps.extensions&quot;]), angular.module(&quot;google-maps.directives.api.managers&quot;, []), angular.module(&quot;google-maps.directives.api.models.child&quot;, [&quot;google-maps.directives.api.utils&quot;]), angular.module(&quot;google-maps.directives.api.models.parent&quot;, [&quot;google-maps.directives.api.managers&quot;, &quot;google-maps.directives.api.models.child&quot;]), angular.module(&quot;google-maps.directives.api&quot;, [&quot;google-maps.directives.api.models.parent&quot;]), angular.module(&quot;google-maps&quot;, [&quot;google-maps.directives.api&quot;]).factory(&quot;debounce&quot;, [&quot;$timeout&quot;, function (a) {
		return function (b) {
			var c;
			return c = 0, function () {
				var d, e, f;
				return f = this, d = arguments, c++, e = function (a) {
					return function () {
						return a === c ? b.apply(f, d) : void 0
					}
				}(c), a(e, 0, !0)
			}
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps.extensions&quot;).service(&quot;ExtendGWin&quot;, function () {
		return {
			init: _.once(function () {
				return (google || (&quot;undefined&quot; != typeof google &amp;&amp; null !== google ? google.maps : void 0) || null != google.maps.InfoWindow) &amp;&amp; (google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open, google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close, google.maps.InfoWindow.prototype._isOpen = !1, google.maps.InfoWindow.prototype.open = function (a, b) {
					this._isOpen = !0, this._open(a, b)
				}, google.maps.InfoWindow.prototype.close = function () {
					this._isOpen = !1, this._close()
				}, google.maps.InfoWindow.prototype.isOpen = function (a) {
					return null == a &amp;&amp; (a = void 0), null == a ? this._isOpen : this._isOpen = a
				}, window.InfoBox) ? (window.InfoBox.prototype._open = window.InfoBox.prototype.open, window.InfoBox.prototype._close = window.InfoBox.prototype.close, window.InfoBox.prototype._isOpen = !1, window.InfoBox.prototype.open = function (a, b) {
					this._isOpen = !0, this._open(a, b)
				}, window.InfoBox.prototype.close = function () {
					this._isOpen = !1, this._close()
				}, window.InfoBox.prototype.isOpen = function (a) {
					return null == a &amp;&amp; (a = void 0), null == a ? this._isOpen : this._isOpen = a
				}, MarkerLabel_.prototype.setContent = function () {
					var a;
					a = this.marker_.get(&quot;labelContent&quot;), a &amp;&amp; !_.isEqual(this.oldContent, a) &amp;&amp; (&quot;undefined&quot; == typeof(null != a ? a.nodeType : void 0) ? (this.labelDiv_.innerHTML = a, this.eventDiv_.innerHTML = this.labelDiv_.innerHTML, this.oldContent = a) : (this.labelDiv_.innerHTML = &quot;&quot;, this.labelDiv_.appendChild(a), a = a.cloneNode(!0), this.eventDiv_.appendChild(a), this.oldContent = a))
				}, MarkerLabel_.prototype.onRemove = function () {
					null != this.labelDiv_.parentNode &amp;&amp; this.labelDiv_.parentNode.removeChild(this.labelDiv_), null != this.eventDiv_.parentNode &amp;&amp; this.eventDiv_.parentNode.removeChild(this.eventDiv_), this.listeners_ &amp;&amp; this.listeners_.length &amp;&amp; this.listeners_.forEach(function (a) {
						return google.maps.event.removeListener(a)
					})
				}) : void 0
			})
		}
	})
}.call(this),function () {
	_.intersectionObjects = function (a, b, c) {
		var d;
		return null == c &amp;&amp; (c = void 0), d = _.map(a, function (a) {
			return _.find(b, function (b) {
				return null != c ? c(a, b) : _.isEqual(a, b)
			})
		}), _.filter(d, function (a) {
			return null != a
		})
	}, _.containsObject = _.includeObject = function (a, b, c) {
		return null == c &amp;&amp; (c = void 0), null === a ? !1 : _.any(a, function (a) {
			return null != c ? c(a, b) : _.isEqual(a, b)
		})
	}, _.differenceObjects = function (a, b, c) {
		return null == c &amp;&amp; (c = void 0), _.filter(a, function (a) {
			return !_.containsObject(b, a, c)
		})
	}, _.withoutObjects = _.differenceObjects, _.indexOfObject = function (a, b, c, d) {
		var e, f;
		if (null == a)return -1;
		if (e = 0, f = a.length, d) {
			if (&quot;number&quot; != typeof d)return e = _.sortedIndex(a, b), a[e] === b ? e : -1;
			e = 0 &gt; d ? Math.max(0, f + d) : d
		}
		for (; f &gt; e;) {
			if (null != c) {
				if (c(a[e], b))return e
			} else if (_.isEqual(a[e], b))return e;
			e++
		}
		return -1
	}, _[&quot;extends&quot;] = function (a) {
		return _.reduce(a, function (a, b) {
			return _.extend(a, b)
		}, {})
	}, _.isNullOrUndefined = function (a) {
		return _.isNull(a || _.isUndefined(a))
	}
}.call(this),function () {
	String.prototype.contains = function (a, b) {
		return -1 !== this.indexOf(a, b)
	}, String.prototype.flare = function (a) {
		return null == a &amp;&amp; (a = &quot;nggmap&quot;), a + this
	}, String.prototype.ns = String.prototype.flare
}.call(this),function () {
	var a;
	a = {
		each: function (a, b, c, d, e, f, g) {
			var h;
			if (null == e &amp;&amp; (e = 20), null == f &amp;&amp; (f = 0), null == g &amp;&amp; (g = 1), !g)throw&quot;pause (delay) must be set from _async!&quot;;
			return void 0 === a || (null != a ? a.length : void 0) &lt;= 0 ? void c() : (h = function () {
				var i, j;
				for (i = e, j = f; i-- &amp;&amp; j &lt; (a ? a.length : j + 1);)b(a[j], j), ++j;
				if (a) {
					if (j &lt; a.length)return f = j, null != d &amp;&amp; d(), setTimeout(h, g);
					if (c)return c()
				}
			})()
		}, map: function (a, b, c, d, e) {
			var f;
			return f = [], null == a ? f : _async.each(a, function (a) {
				return f.push(b(a))
			}, function () {
				return c(f)
			}, d, e)
		}
	}, window._async = a, angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;async&quot;, function () {
		return window._async
	})
}.call(this),function () {
	var a = [].indexOf || function (a) {
			for (var b = 0, c = this.length; c &gt; b; b++)if (b in this &amp;&amp; this[b] === a)return b;
			return -1
		};
	angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;BaseObject&quot;, function () {
		var b, c;
		return c = [&quot;extended&quot;, &quot;included&quot;], b = function () {
			function b() {
			}

			return b.extend = function (b) {
				var d, e, f;
				for (d in b)e = b[d], a.call(c, d) &lt; 0 &amp;&amp; (this[d] = e);
				return null != (f = b.extended) &amp;&amp; f.apply(this), this
			}, b.include = function (b) {
				var d, e, f;
				for (d in b)e = b[d], a.call(c, d) &lt; 0 &amp;&amp; (this.prototype[d] = e);
				return null != (f = b.included) &amp;&amp; f.apply(this), this
			}, b
		}()
	})
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;ChildEvents&quot;, function () {
		return {
			onChildCreation: function () {
			}
		}
	})
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).service(&quot;CtrlHandle&quot;, [&quot;$q&quot;, function (a) {
		var b;
		return b = {
			handle: function (b) {
				return b.deferred = a.defer(), {
					getScope: function () {
						return b
					}
				}
			}, mapPromise: function (a, b) {
				var c;
				return c = b.getScope(), c.deferred.promise.then(function (b) {
					return a.map = b
				}), c.deferred.promise
			}
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).service(&quot;EventsHelper&quot;, [&quot;Logger&quot;, function (a) {
		return {
			setEvents: function (b, c, d, e) {
				return angular.isDefined(c.events) &amp;&amp; null != c.events &amp;&amp; angular.isObject(c.events) ? _.compact(_.map(c.events, function (f, g) {
					var h;
					return e &amp;&amp; (h = _(e).contains(g)), c.events.hasOwnProperty(g) &amp;&amp; angular.isFunction(c.events[g]) &amp;&amp; !h ? google.maps.event.addListener(b, g, function () {
						return f.apply(c, [b, g, d, arguments])
					}) : a.info(&quot;EventHelper: invalid event listener &quot; + g)
				})) : void 0
			}, removeEvents: function (a) {
				return null != a ? a.forEach(function (a) {
					return google.maps.event.removeListener(a)
				}) : void 0
			}
		}
	}])
}.call(this),function () {
	var a = {}.hasOwnProperty, b = function (b, c) {
		function d() {
			this.constructor = b
		}

		for (var e in c)a.call(c, e) &amp;&amp; (b[e] = c[e]);
		return d.prototype = c.prototype, b.prototype = new d, b.__super__ = c.prototype, b
	};
	angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;FitHelper&quot;, [&quot;BaseObject&quot;, &quot;Logger&quot;, function (a) {
		var c, d;
		return c = function (a) {
			function c() {
				return d = c.__super__.constructor.apply(this, arguments)
			}

			return b(c, a), c.prototype.fit = function (a, b) {
				var c, d;
				return b &amp;&amp; a &amp;&amp; a.length &gt; 0 ? (c = new google.maps.LatLngBounds, d = !1, _async.each(a, function (a) {
					return a ? (d || (d = !0), c.extend(a.getPosition())) : void 0
				}, function () {
					return d ? b.fitBounds(c) : void 0
				})) : void 0
			}, c
		}(a)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).service(&quot;GmapUtil&quot;, [&quot;Logger&quot;, &quot;$compile&quot;, function (a, b) {
		var c, d, e, f, g;
		return d = function (a) {
			return Array.isArray(a) &amp;&amp; 2 === a.length ? a[1] : angular.isDefined(a.type) &amp;&amp; &quot;Point&quot; === a.type ? a.coordinates[1] : a.latitude
		}, e = function (a) {
			return Array.isArray(a) &amp;&amp; 2 === a.length ? a[0] : angular.isDefined(a.type) &amp;&amp; &quot;Point&quot; === a.type ? a.coordinates[0] : a.longitude
		}, c = function (a) {
			return a ? Array.isArray(a) &amp;&amp; 2 === a.length ? new google.maps.LatLng(a[1], a[0]) : angular.isDefined(a.type) &amp;&amp; &quot;Point&quot; === a.type ? new google.maps.LatLng(a.coordinates[1], a.coordinates[0]) : new google.maps.LatLng(a.latitude, a.longitude) : void 0
		}, f = function (a, b) {
			return a ? (Array.isArray(a) &amp;&amp; 2 === a.length ? (a[1] = b.lat(), a[0] = b.lng()) : angular.isDefined(a.type) &amp;&amp; &quot;Point&quot; === a.type ? (a.coordinates[1] = b.lat(), a.coordinates[0] = b.lng()) : (a.latitude = b.lat(), a.longitude = b.lng()), a) : void 0
		}, g = function (a) {
			if (angular.isUndefined(a))return !1;
			if (_.isArray(a)) {
				if (2 === a.length)return !0
			} else if (null != a &amp;&amp; (null != a ? a.type : void 0) &amp;&amp; &quot;Point&quot; === a.type &amp;&amp; _.isArray(a.coordinates) &amp;&amp; 2 === a.coordinates.length)return !0;
			return a &amp;&amp; angular.isDefined((null != a ? a.latitude : void 0) &amp;&amp; angular.isDefined(null != a ? a.longitude : void 0)) ? !0 : !1
		}, {
			getLabelPositionPoint: function (a) {
				var b, c;
				return void 0 === a ? void 0 : (a = /^([-\d\.]+)\s([-\d\.]+)$/.exec(a), b = parseFloat(a[1]), c = parseFloat(a[2]), null != b &amp;&amp; null != c ? new google.maps.Point(b, c) : void 0)
			}, createMarkerOptions: function (a, b, d, e) {
				var f;
				return null == e &amp;&amp; (e = void 0), null == d &amp;&amp; (d = {}), f = angular.extend({}, d, {
					position: null != d.position ? d.position : c(a),
					visible: null != d.visible ? d.visible : g(a)
				}), (null != d.icon || null != b) &amp;&amp; (f = angular.extend(f, {icon: null != d.icon ? d.icon : b})), null != e &amp;&amp; (f.map = e), f
			}, createWindowOptions: function (d, e, f, g) {
				return null != f &amp;&amp; null != g &amp;&amp; null != b ? angular.extend({}, g, {
					content: this.buildContent(e, g, f),
					position: null != g.position ? g.position : angular.isObject(d) ? d.getPosition() : c(e.coords)
				}) : g ? g : (a.error(&quot;infoWindow defaults not defined&quot;), f ? void 0 : a.error(&quot;infoWindow content not defined&quot;))
			}, buildContent: function (a, c, d) {
				var e, f;
				return null != c.content ? f = c.content : null != b ? (e = b(d)(a), e.length &gt; 0 &amp;&amp; (f = e[0])) : f = d, f
			}, defaultDelay: 50, isTrue: function (a) {
				return angular.isDefined(a) &amp;&amp; null !== a &amp;&amp; a === !0 || &quot;1&quot; === a || &quot;y&quot; === a || &quot;true&quot; === a
			}, isFalse: function (a) {
				return -1 !== [&quot;false&quot;, &quot;FALSE&quot;, 0, &quot;n&quot;, &quot;N&quot;, &quot;no&quot;, &quot;NO&quot;].indexOf(a)
			}, getCoords: c, validateCoords: g, equalCoords: function (a, b) {
				return d(a) === d(b) &amp;&amp; e(a) === e(b)
			}, validatePath: function (a) {
				var b, c, d, e;
				if (c = 0, angular.isUndefined(a.type)) {
					if (!Array.isArray(a) || a.length &lt; 2)return !1;
					for (; c &lt; a.length;) {
						if (!(angular.isDefined(a[c].latitude) &amp;&amp; angular.isDefined(a[c].longitude) || &quot;function&quot; == typeof a[c].lat &amp;&amp; &quot;function&quot; == typeof a[c].lng))return !1;
						c++
					}
					return !0
				}
				if (angular.isUndefined(a.coordinates))return !1;
				if (&quot;Polygon&quot; === a.type) {
					if (a.coordinates[0].length &lt; 4)return !1;
					b = a.coordinates[0]
				} else if (&quot;MultiPolygon&quot; === a.type) {
					if (e = {max: 0, index: 0}, _.forEach(a.coordinates, function (a, b) {
							return a[0].length &gt; this.max ? (this.max = a[0].length, this.index = b) : void 0
						}, e), d = a.coordinates[e.index], b = d[0], b.length &lt; 4)return !1
				} else {
					if (&quot;LineString&quot; !== a.type)return !1;
					if (a.coordinates.length &lt; 2)return !1;
					b = a.coordinates
				}
				for (; c &lt; b.length;) {
					if (2 !== b[c].length)return !1;
					c++
				}
				return !0
			}, convertPathPoints: function (a) {
				var b, c, d, e, f;
				if (c = 0, e = new google.maps.MVCArray, angular.isUndefined(a.type))for (; c &lt; a.length;)angular.isDefined(a[c].latitude) &amp;&amp; angular.isDefined(a[c].longitude) ? d = new google.maps.LatLng(a[c].latitude, a[c].longitude) : &quot;function&quot; == typeof a[c].lat &amp;&amp; &quot;function&quot; == typeof a[c].lng &amp;&amp; (d = a[c]), e.push(d), c++; else for (&quot;Polygon&quot; === a.type ? b = a.coordinates[0] : &quot;MultiPolygon&quot; === a.type ? (f = {
					max: 0,
					index: 0
				}, _.forEach(a.coordinates, function (a, b) {
					return a[0].length &gt; this.max ? (this.max = a[0].length, this.index = b) : void 0
				}, f), b = a.coordinates[f.index][0]) : &quot;LineString&quot; === a.type &amp;&amp; (b = a.coordinates); c &lt; b.length;)e.push(new google.maps.LatLng(b[c][1], b[c][0])), c++;
				return e
			}, extendMapBounds: function (a, b) {
				var c, d;
				for (c = new google.maps.LatLngBounds, d = 0; d &lt; b.length;)c.extend(b.getAt(d)), d++;
				return a.fitBounds(c)
			}, getPath: function (a, b) {
				var c;
				return c = a, _.each(b.split(&quot;.&quot;), function (a) {
					return c ? c = c[a] : void 0
				}), c
			}, setCoordsFromEvent: f
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).service(&quot;IsReady&quot;.ns(), [&quot;$q&quot;, &quot;$timeout&quot;, function (a, b) {
		var c, d, e;
		return c = 0, e = [], d = function () {
			return a.all(e)
		}, {
			spawn: function () {
				var b;
				return b = a.defer(), e.push(b.promise), c += 1, {instance: c, deferred: b}
			}, promises: d, instances: function () {
				return c
			}, promise: function (e) {
				var f, g;
				return null == e &amp;&amp; (e = 1), f = a.defer(), g = function () {
					return b(function () {
						return c !== e ? g() : f.resolve(d())
					})
				}, g(), f.promise
			}
		}
	}])
}.call(this),function () {
	var a = {}.hasOwnProperty, b = function (b, c) {
		function d() {
			this.constructor = b
		}

		for (var e in c)a.call(c, e) &amp;&amp; (b[e] = c[e]);
		return d.prototype = c.prototype, b.prototype = new d, b.__super__ = c.prototype, b
	};
	angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;Linked&quot;, [&quot;BaseObject&quot;, function (a) {
		var c;
		return c = function (a) {
			function c(a, b, c, d) {
				this.scope = a, this.element = b, this.attrs = c, this.ctrls = d
			}

			return b(c, a), c
		}(a)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).service(&quot;Logger&quot;, [&quot;$log&quot;, function (a) {
		return {
			doLog: !1, info: function (b) {
				return this.doLog ? null != a ? a.info(b) : console.info(b) : void 0
			}, error: function (b) {
				return this.doLog ? null != a ? a.error(b) : console.error(b) : void 0
			}, warn: function (b) {
				return this.doLog ? null != a ? a.warn(b) : console.warn(b) : void 0
			}
		}
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;ModelKey&quot;, [&quot;BaseObject&quot;, &quot;GmapUtil&quot;, function (b, d) {
		var e;
		return e = function (b) {
			function e(b) {
				this.scope = b, this.setIdKey = a(this.setIdKey, this), this.modelKeyComparison = a(this.modelKeyComparison, this), e.__super__.constructor.call(this), this.defaultIdKey = &quot;id&quot;, this.idKey = void 0
			}

			return c(e, b), e.prototype.evalModelHandle = function (a, b) {
				return void 0 === a || void 0 === b ? void 0 : &quot;self&quot; === b ? a : d.getPath(a, b)
			}, e.prototype.modelKeyComparison = function (a, b) {
				var c;
				if (c = null != this.scope.coords ? this.scope : this.parentScope, null == c)throw&quot;No scope or parentScope set!&quot;;
				return d.equalCoords(this.evalModelHandle(a, c.coords), this.evalModelHandle(b, c.coords))
			}, e.prototype.setIdKey = function (a) {
				return this.idKey = null != a.idKey ? a.idKey : this.defaultIdKey
			}, e.prototype.setVal = function (a, b, c) {
				var d;
				return d = this.modelOrKey(a, b), d = c, a
			}, e.prototype.modelOrKey = function (a, b) {
				var c;
				return c = &quot;self&quot; !== b ? a[b] : a
			}, e
		}(b)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;ModelsWatcher&quot;, [&quot;Logger&quot;, function (a) {
		return {
			figureOutState: function (b, c, d, e, f) {
				var g, h, i, j;
				return g = [], h = {}, i = [], j = [], _async.each(c.models, function (c) {
					var f;
					return null == c[b] ? a.error(&quot;id missing for model &quot; + c.toString() + &quot;, can not use do comparison/insertion&quot;) : (h[c[b]] = {}, null == d[c[b]] ? g.push(c) : (f = d[c[b]], e(c, f.model) ? void 0 : j.push({
						model: c,
						child: f
					})))
				}, function () {
					return _async.each(d.values(), function (c) {
						var d;
						return null == c ? void a.error(&quot;child undefined in ModelsWatcher.&quot;) : null == c.model ? void a.error(&quot;child.model undefined in ModelsWatcher.&quot;) : (d = c.model[b], null == h[d] ? i.push(c) : void 0)
					}, function () {
						return f({adds: g, removals: i, updates: j})
					})
				})
			}
		}
	}])
}.call(this),function () {
	var a, b = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	};
	a = [&quot;get&quot;, &quot;put&quot;, &quot;remove&quot;, &quot;values&quot;, &quot;keys&quot;, &quot;length&quot;, &quot;push&quot;, &quot;didValueStateChange&quot;, &quot;didKeyStateChange&quot;, &quot;slice&quot;, &quot;removeAll&quot;, &quot;allVals&quot;, &quot;allKeys&quot;, &quot;stateChanged&quot;], window.PropMap = function () {
		function c() {
			this.removeAll = b(this.removeAll, this), this.slice = b(this.slice, this), this.push = b(this.push, this), this.keys = b(this.keys, this), this.values = b(this.values, this), this.remove = b(this.remove, this), this.put = b(this.put, this), this.stateChanged = b(this.stateChanged, this), this.get = b(this.get, this), this.length = 0, this.didValueStateChange = !1, this.didKeyStateChange = !1, this.allVals = [], this.allKeys = []
		}

		return c.prototype.get = function (a) {
			return this[a]
		}, c.prototype.stateChanged = function () {
			return this.didValueStateChange = !0, this.didKeyStateChange = !0
		}, c.prototype.put = function (a, b) {
			return null == this.get(a) &amp;&amp; this.length++, this.stateChanged(), this[a] = b
		}, c.prototype.remove = function (a, b) {
			var c;
			return null == b &amp;&amp; (b = !1), b &amp;&amp; !this.get(a) ? void 0 : (c = this[a], delete this[a], this.length--, this.stateChanged(), c)
		}, c.prototype.values = function () {
			var b, c = this;
			return this.didValueStateChange ? (b = [], this.keys().forEach(function (d) {
				return -1 === _.indexOf(a, d) ? b.push(c[d]) : void 0
			}), this.didValueStateChange = !1, this.keys(), this.allVals = b) : this.allVals
		}, c.prototype.keys = function () {
			var b, c;
			return this.didKeyStateChange ? (c = _.keys(this), b = [], _.each(c, function (c) {
				return -1 === _.indexOf(a, c) ? b.push(c) : void 0
			}), this.didKeyStateChange = !1, this.values(), this.allKeys = b) : this.allKeys
		}, c.prototype.push = function (a, b) {
			return null == b &amp;&amp; (b = &quot;key&quot;), this.put(a[b], a)
		}, c.prototype.slice = function () {
			var a = this;
			return this.keys().map(function (b) {
				return a.remove(b)
			})
		}, c.prototype.removeAll = function () {
			return this.slice()
		}, c
	}(), angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;PropMap&quot;, function () {
		return window.PropMap
	})
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.utils&quot;).factory(&quot;nggmap-PropertyAction&quot;, [&quot;Logger&quot;, function () {
		var a;
		return a = function (a, b) {
			var c = this;
			return this.setIfChange = function (c, d) {
				return _.isEqual(d, c || b) ? void 0 : a(c)
			}, this.sic = function (a, b) {
				return c.setIfChange(a, b)
			}, this
		}
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.managers&quot;).factory(&quot;ClustererMarkerManager&quot;, [&quot;Logger&quot;, &quot;FitHelper&quot;, &quot;PropMap&quot;, function (b, d, e) {
		var f;
		return f = function (d) {
			function f(c, d, g, h) {
				var i;
				this.opt_events = h, this.checkSync = a(this.checkSync, this), this.getGMarkers = a(this.getGMarkers, this), this.fit = a(this.fit, this), this.destroy = a(this.destroy, this), this.clear = a(this.clear, this), this.draw = a(this.draw, this), this.removeMany = a(this.removeMany, this), this.remove = a(this.remove, this), this.addMany = a(this.addMany, this), this.add = a(this.add, this), f.__super__.constructor.call(this), i = this, this.opt_options = g, this.clusterer = null != g &amp;&amp; void 0 === d ? new NgMapMarkerClusterer(c, void 0, g) : null != g &amp;&amp; null != d ? new NgMapMarkerClusterer(c, d, g) : new NgMapMarkerClusterer(c), this.propMapGMarkers = new e, this.attachEvents(this.opt_events, &quot;opt_events&quot;), this.clusterer.setIgnoreHidden(!0), this.noDrawOnSingleAddRemoves = !0, b.info(this)
			}

			return c(f, d), f.prototype.checkKey = function (a) {
				var b;
				return null == a.key ? (b = &quot;gMarker.key undefined and it is REQUIRED!!&quot;, Logger.error(b)) : void 0
			}, f.prototype.add = function (a) {
				var b;
				return this.checkKey(a), b = null != this.propMapGMarkers.get(a.key), this.clusterer.addMarker(a, this.noDrawOnSingleAddRemoves), this.propMapGMarkers.put(a.key, a), this.checkSync()
			}, f.prototype.addMany = function (a) {
				var b = this;
				return a.forEach(function (a) {
					return b.add(a)
				})
			}, f.prototype.remove = function (a) {
				var b;
				return this.checkKey(a), b = this.propMapGMarkers.get(a.key), b &amp;&amp; (this.clusterer.removeMarker(a, this.noDrawOnSingleAddRemoves), this.propMapGMarkers.remove(a.key)), this.checkSync()
			}, f.prototype.removeMany = function (a) {
				var b = this;
				return a.forEach(function (a) {
					return b.remove(a)
				})
			}, f.prototype.draw = function () {
				return this.clusterer.repaint()
			}, f.prototype.clear = function () {
				return this.removeMany(this.getGMarkers()), this.clusterer.repaint()
			}, f.prototype.attachEvents = function (a, c) {
				var d, e, f;
				if (angular.isDefined(a) &amp;&amp; null != a &amp;&amp; angular.isObject(a)) {
					f = [];
					for (e in a)d = a[e], a.hasOwnProperty(e) &amp;&amp; angular.isFunction(a[e]) ? (b.info(&quot;&quot; + c + &quot;: Attaching event: &quot; + e + &quot; to clusterer&quot;), f.push(google.maps.event.addListener(this.clusterer, e, a[e]))) : f.push(void 0);
					return f
				}
			}, f.prototype.clearEvents = function (a) {
				var c, d, e;
				if (angular.isDefined(a) &amp;&amp; null != a &amp;&amp; angular.isObject(a)) {
					e = [];
					for (d in a)c = a[d], a.hasOwnProperty(d) &amp;&amp; angular.isFunction(a[d]) ? (b.info(&quot;&quot; + optionsName + &quot;: Clearing event: &quot; + d + &quot; to clusterer&quot;), e.push(google.maps.event.clearListeners(this.clusterer, d))) : e.push(void 0);
					return e
				}
			}, f.prototype.destroy = function () {
				return this.clearEvents(this.opt_events), this.clearEvents(this.opt_internal_events), this.clear()
			}, f.prototype.fit = function () {
				return f.__super__.fit.call(this, this.getGMarkers(), this.clusterer.getMap())
			}, f.prototype.getGMarkers = function () {
				return this.clusterer.getMarkers().values()
			}, f.prototype.checkSync = function () {
				if (this.getGMarkers().length !== this.propMapGMarkers.length)throw&quot;GMarkers out of Sync in MarkerClusterer&quot;
			}, f
		}(d)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.managers&quot;).factory(&quot;MarkerManager&quot;, [&quot;Logger&quot;, &quot;FitHelper&quot;, &quot;PropMap&quot;, function (b, d, e) {
		var f;
		return f = function (f) {
			function g(c) {
				this.getGMarkers = a(this.getGMarkers, this), this.fit = a(this.fit, this), this.handleOptDraw = a(this.handleOptDraw, this), this.clear = a(this.clear, this), this.draw = a(this.draw, this), this.removeMany = a(this.removeMany, this), this.remove = a(this.remove, this), this.addMany = a(this.addMany, this), this.add = a(this.add, this), g.__super__.constructor.call(this), this.gMap = c, this.gMarkers = new e, this.$log = b, this.$log.info(this)
			}

			return c(g, f), g.include(d), g.prototype.add = function (a, c) {
				var d, e;
				if (null == c &amp;&amp; (c = !0), null == a.key)throw e = &quot;gMarker.key undefined and it is REQUIRED!!&quot;, b.error(e), e;
				return d = null != this.gMarkers.get(a.key), d ? void 0 : (this.handleOptDraw(a, c, !0), this.gMarkers.put(a.key, a))
			}, g.prototype.addMany = function (a) {
				var b = this;
				return a.forEach(function (a) {
					return b.add(a)
				})
			}, g.prototype.remove = function (a, b) {
				return null == b &amp;&amp; (b = !0), this.handleOptDraw(a, b, !1), this.gMarkers.get(a.key) ? this.gMarkers.remove(a.key) : void 0
			}, g.prototype.removeMany = function () {
				var a = this;
				return this.gMarkers.values().forEach(function (b) {
					return a.remove(b)
				})
			}, g.prototype.draw = function () {
				var a, b = this;
				return a = [], this.gMarkers.values().forEach(function (c) {
					return c.isDrawn ? void 0 : c.doAdd ? (c.setMap(b.gMap), c.isDrawn = !0) : a.push(c)
				}), a.forEach(function (a) {
					return a.isDrawn = !1, b.remove(a, !0)
				})
			}, g.prototype.clear = function () {
				return this.gMarkers.values().forEach(function (a) {
					return a.setMap(null)
				}), delete this.gMarkers, this.gMarkers = new e
			}, g.prototype.handleOptDraw = function (a, b, c) {
				return b === !0 ? (a.setMap(c ? this.gMap : null), a.isDrawn = !0) : (a.isDrawn = !1, a.doAdd = c)
			}, g.prototype.fit = function () {
				return g.__super__.fit.call(this, this.getGMarkers(), this.gMap)
			}, g.prototype.getGMarkers = function () {
				return this.gMarkers.values()
			}, g
		}(d)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).factory(&quot;array-sync&quot;, [&quot;add-events&quot;, function (a) {
		return function (b, c, d, e) {
			var f, g, h, i, j, k, l, m, n;
			return i = !1, m = c.$eval(d), c[&quot;static&quot;] || (j = {
				set_at: function (a) {
					var c;
					if (!i &amp;&amp; (c = b.getAt(a)))return c.lng &amp;&amp; c.lat ? (m[a].latitude = c.lat(), m[a].longitude = c.lng()) : m[a] = c
				}, insert_at: function (a) {
					var c;
					if (!i &amp;&amp; (c = b.getAt(a)))return c.lng &amp;&amp; c.lat ? m.splice(a, 0, {
						latitude: c.lat(),
						longitude: c.lng()
					}) : m.splice(a, 0, c)
				}, remove_at: function (a) {
					return i ? void 0 : m.splice(a, 1)
				}
			}, &quot;Polygon&quot; === m.type ? f = m.coordinates[0] : &quot;LineString&quot; === m.type &amp;&amp; (f = m.coordinates), g = {
				set_at: function (a) {
					var c;
					if (!i &amp;&amp; (c = b.getAt(a), c &amp;&amp; c.lng &amp;&amp; c.lat))return f[a][1] = c.lat(), f[a][0] = c.lng()
				}, insert_at: function (a) {
					var c;
					if (!i &amp;&amp; (c = b.getAt(a), c &amp;&amp; c.lng &amp;&amp; c.lat))return f.splice(a, 0, [c.lng(), c.lat()])
				}, remove_at: function (a) {
					return i ? void 0 : f.splice(a, 1)
				}
			}, l = a(b, angular.isUndefined(m.type) ? j : g)), k = function (a) {
				var c, d, f, g, h, j, k, l;
				if (i = !0, j = b, c = !1, a) {
					for (d = 0, k = j.getLength(), g = a.length, f = Math.min(k, g), h = void 0; f &gt; d;)l = j.getAt(d), h = a[d], &quot;function&quot; == typeof h.equals ? h.equals(l) || (j.setAt(d, h), c = !0) : (l.lat() !== h.latitude || l.lng() !== h.longitude) &amp;&amp; (j.setAt(d, new google.maps.LatLng(h.latitude, h.longitude)), c = !0), d++;
					for (; g &gt; d;)h = a[d], j.push(&quot;function&quot; == typeof h.lat &amp;&amp; &quot;function&quot; == typeof h.lng ? h : new google.maps.LatLng(h.latitude, h.longitude)), c = !0, d++;
					for (; k &gt; d;)j.pop(), c = !0, d++
				}
				return i = !1, c ? e(j) : void 0
			}, h = function (a) {
				var c, d, f, g, h, j, k, l, n;
				if (i = !0, k = b, d = !1, a) {
					for (&quot;Polygon&quot; === m.type ? c = a.coordinates[0] : &quot;LineString&quot; === m.type &amp;&amp; (c = a.coordinates), f = 0, l = k.getLength(), h = c.length, g = Math.min(l, h), j = void 0; g &gt; f;)n = k.getAt(f), j = c[f], (n.lat() !== j[1] || n.lng() !== j[0]) &amp;&amp; (k.setAt(f, new google.maps.LatLng(j[1], j[0])), d = !0), f++;
					for (; h &gt; f;)j = c[f], k.push(new google.maps.LatLng(j[1], j[0])), d = !0, f++;
					for (; l &gt; f;)k.pop(), d = !0, f++
				}
				return i = !1, d ? e(k) : void 0
			}, c[&quot;static&quot;] || (n = angular.isUndefined(m.type) ? c.$watchCollection(d, k) : c.$watch(d, h, !0)), function () {
				return l &amp;&amp; (l(), l = null), n ? (n(), n = null) : void 0
			}
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).factory(&quot;add-events&quot;, [&quot;$timeout&quot;, function (a) {
		var b, c;
		return b = function (b, c, d) {
			return google.maps.event.addListener(b, c, function () {
				return d.apply(this, arguments), a(function () {
				}, !0)
			})
		}, c = function (a, c, d) {
			var e;
			return d ? b(a, c, d) : (e = [], angular.forEach(c, function (c, d) {
				return e.push(b(a, d, c))
			}), function () {
				return angular.forEach(e, function (a) {
					return google.maps.event.removeListener(a)
				}), e = null
			})
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps.directives.api.models.child&quot;).factory(&quot;DrawFreeHandChildModel&quot;, [&quot;Logger&quot;, &quot;$q&quot;, function (a, b) {
		var c, d;
		return c = function (a, b, c) {
			var d, e;
			return this.polys = b, e = new google.maps.Polyline({
				map: a,
				clickable: !1
			}), d = google.maps.event.addListener(a, &quot;mousemove&quot;, function (a) {
				return e.getPath().push(a.latLng)
			}), void google.maps.event.addListenerOnce(a, &quot;mouseup&quot;, function () {
				var f;
				return google.maps.event.removeListener(d), f = e.getPath(), e.setMap(null), b.push(new google.maps.Polygon({
					map: a,
					path: f
				})), e = null, google.maps.event.clearListeners(a.getDiv(), &quot;mousedown&quot;), c()
			})
		}, d = function (d) {
			var e, f, g = this;
			return this.map = d, f = function () {
				var a;
				return null != (a = g.deferred) &amp;&amp; a.resolve(), g.map.setOptions(g.oldOptions)
			}, e = function () {
				return a.info(&quot;disabling map move&quot;), g.oldOptions = d.getOptions(), g.map.setOptions({
					draggable: !1,
					zoomControl: !1,
					scrollwheel: !1,
					disableDoubleClickZoom: !1
				})
			}, this.engage = function (d) {
				return g.polys = d, g.deferred = b.defer(), e(), a.info(&quot;DrawFreeHandChildModel is engaged (drawing).&quot;), google.maps.event.addDomListener(g.map.getDiv(), &quot;mousedown&quot;, function () {
					return c(g.map, g.polys, f)
				}), g.deferred.promise
			}, this
		}
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.child&quot;).factory(&quot;MarkerLabelChildModel&quot;, [&quot;BaseObject&quot;, &quot;GmapUtil&quot;, function (b, d) {
		var e;
		return e = function (b) {
			function e(b, c, d) {
				this.destroy = a(this.destroy, this), this.setOptions = a(this.setOptions, this);
				var f;
				e.__super__.constructor.call(this), f = this, this.gMarker = b, this.setOptions(c), this.gMarkerLabel = new MarkerLabel_(this.gMarker, c.crossImage, c.handCursor), this.gMarker.set(&quot;setMap&quot;, function (a) {
					return f.gMarkerLabel.setMap(a), google.maps.Marker.prototype.setMap.apply(this, arguments)
				}), this.gMarker.setMap(d)
			}

			return c(e, b), e.include(d), e.prototype.setOption = function (a, b) {
				return this.gMarker.set(a, b)
			}, e.prototype.setOptions = function (a) {
				var b, c;
				return (null != a ? a.labelContent : void 0) &amp;&amp; this.gMarker.set(&quot;labelContent&quot;, a.labelContent), (null != a ? a.labelAnchor : void 0) &amp;&amp; this.gMarker.set(&quot;labelAnchor&quot;, this.getLabelPositionPoint(a.labelAnchor)), this.gMarker.set(&quot;labelClass&quot;, a.labelClass || &quot;labels&quot;), this.gMarker.set(&quot;labelStyle&quot;, a.labelStyle || {opacity: 100}), this.gMarker.set(&quot;labelInBackground&quot;, a.labelInBackground || !1), a.labelVisible || this.gMarker.set(&quot;labelVisible&quot;, !0), a.raiseOnDrag || this.gMarker.set(&quot;raiseOnDrag&quot;, !0), a.clickable || this.gMarker.set(&quot;clickable&quot;, !0), a.draggable || this.gMarker.set(&quot;draggable&quot;, !1), a.optimized || this.gMarker.set(&quot;optimized&quot;, !1), a.crossImage = null != (b = a.crossImage) ? b : document.location.protocol + &quot;//maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png&quot;, a.handCursor = null != (c = a.handCursor) ? c : document.location.protocol + &quot;//maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur&quot;
			}, e.prototype.destroy = function () {
				return null != this.gMarkerLabel.labelDiv_.parentNode &amp;&amp; null != this.gMarkerLabel.eventDiv_.parentNode ? this.gMarkerLabel.onRemove() : void 0
			}, e
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.child&quot;).factory(&quot;MarkerChildModel&quot;, [&quot;ModelKey&quot;, &quot;GmapUtil&quot;, &quot;Logger&quot;, &quot;$injector&quot;, &quot;EventsHelper&quot;, function (b, d, e, f, g) {
		var h;
		return h = function (b) {
			function h(b, c, d, f, g, i, j, k, l) {
				var m = this;
				this.model = b, this.parentScope = c, this.gMap = d, this.$timeout = f, this.defaults = g, this.doClick = i, this.gMarkerManager = j, this.idKey = null != k ? k : &quot;id&quot;, this.doDrawSelf = null != l ? l : !0, this.watchDestroy = a(this.watchDestroy, this), this.internalEvents = a(this.internalEvents, this), this.setLabelOptions = a(this.setLabelOptions, this), this.setOptions = a(this.setOptions, this), this.setIcon = a(this.setIcon, this), this.setCoords = a(this.setCoords, this), this.destroy = a(this.destroy, this), this.maybeSetScopeValue = a(this.maybeSetScopeValue, this), this.createMarker = a(this.createMarker, this), this.setMyScope = a(this.setMyScope, this), null != this.model[this.idKey] &amp;&amp; (this.id = this.model[this.idKey]), this.iconKey = this.parentScope.icon, this.coordsKey = this.parentScope.coords, this.clickKey = this.parentScope.click(), this.optionsKey = this.parentScope.options, this.needRedraw = !1, h.__super__.constructor.call(this, this.parentScope.$new(!1)), this.scope.model = this.model, this.setMyScope(this.model, void 0, !0), this.createMarker(this.model), this.scope.$watch(&quot;model&quot;, function (a, b) {
					return a !== b ? (m.setMyScope(a, b), m.needRedraw = !0) : void 0
				}, !0), e.info(this), this.watchDestroy(this.scope)
			}

			return c(h, b), h.include(d), h.include(g), h.prototype.setMyScope = function (a, b, c) {
				var d = this;
				return null == b &amp;&amp; (b = void 0), null == c &amp;&amp; (c = !1), this.maybeSetScopeValue(&quot;icon&quot;, a, b, this.iconKey, this.evalModelHandle, c, this.setIcon), this.maybeSetScopeValue(&quot;coords&quot;, a, b, this.coordsKey, this.evalModelHandle, c, this.setCoords), _.isFunction(this.clickKey) &amp;&amp; f ? this.scope.click = function () {
					return f.invoke(d.clickKey, void 0, {$markerModel: a})
				} : (this.maybeSetScopeValue(&quot;click&quot;, a, b, this.clickKey, this.evalModelHandle, c), this.createMarker(a, b, c))
			}, h.prototype.createMarker = function (a, b, c) {
				return null == b &amp;&amp; (b = void 0), null == c &amp;&amp; (c = !1), this.maybeSetScopeValue(&quot;options&quot;, a, b, this.optionsKey, this.evalModelHandle, c, this.setOptions), this.parentScope.options &amp;&amp; !this.scope.options ? e.error(&quot;Options not found on model!&quot;) : void 0
			}, h.prototype.maybeSetScopeValue = function (a, b, c, d, e, f, g) {
				var h, i;
				return null == g &amp;&amp; (g = void 0), void 0 === c ? (this.scope[a] = e(b, d), void(f || null != g &amp;&amp; g(this.scope))) : (i = e(c, d), h = e(b, d), h !== i &amp;&amp; (this.scope[a] = h, !f &amp;&amp; (null != g &amp;&amp; g(this.scope), this.doDrawSelf)) ? this.gMarkerManager.draw() : void 0)
			}, h.prototype.destroy = function () {
				return null == this.gMarker || (this.removeEvents(this.externalListeners), this.removeEvents(this.internalListeners), this.gMarkerManager.remove(this.gMarker, !0), delete this.gMarker, this.scope.$$destroyed) ? void 0 : this.scope.$destroy()
			}, h.prototype.setCoords = function (a) {
				return a.$id === this.scope.$id &amp;&amp; void 0 !== this.gMarker ? null != a.coords ? this.validateCoords(this.scope.coords) ? (this.gMarker.setPosition(this.getCoords(a.coords)), this.gMarker.setVisible(this.validateCoords(a.coords)), this.gMarkerManager.add(this.gMarker)) : void e.error(&quot;MarkerChildMarker cannot render marker as scope.coords as no position on marker: &quot; + JSON.stringify(this.model)) : this.gMarkerManager.remove(this.gMarker) : void 0
			}, h.prototype.setIcon = function (a) {
				return a.$id === this.scope.$id &amp;&amp; void 0 !== this.gMarker ? (this.gMarkerManager.remove(this.gMarker), this.gMarker.setIcon(a.icon), this.gMarkerManager.add(this.gMarker), this.gMarker.setPosition(this.getCoords(a.coords)), this.gMarker.setVisible(this.validateCoords(a.coords))) : void 0
			}, h.prototype.setOptions = function (a) {
				var b, c;
				if (a.$id === this.scope.$id &amp;&amp; (null != this.gMarker &amp;&amp; (this.gMarkerManager.remove(this.gMarker), delete this.gMarker), null != (c = a.coords) ? c : &quot;function&quot; == typeof a.icon ? a.icon(null != a.options) : void 0))return this.opts = this.createMarkerOptions(a.coords, a.icon, a.options), delete this.gMarker, this.gMarker = a.isLabel ? new MarkerWithLabel(this.setLabelOptions(this.opts)) : new google.maps.Marker(this.opts), this.externalListeners = this.setEvents(this.gMarker, this.parentScope, this.model, b = [&quot;dragend&quot;]), this.internalListeners = this.setEvents(this.gMarker, {events: this.internalEvents()}, this.model), null != this.id &amp;&amp; (this.gMarker.key = this.id), this.gMarkerManager.add(this.gMarker)
			}, h.prototype.setLabelOptions = function (a) {
				return a.labelAnchor = this.getLabelPositionPoint(a.labelAnchor), a
			}, h.prototype.internalEvents = function () {
				var a = this;
				return {
					dragend: function (b, c, d, e) {
						var f, g, h;
						return f = a.setCoordsFromEvent(a.modelOrKey(a.scope.model, a.coordsKey), a.gMarker.getPosition()), a.scope.model = a.setVal(d, a.coordsKey, f), null != (null != (g = a.parentScope.events) ? g.dragend : void 0) &amp;&amp; null != (h = a.parentScope.events) &amp;&amp; h.dragend(b, c, a.scope.model, e), a.scope.$apply()
					}, click: function () {
						return a.doClick &amp;&amp; null != a.scope.click ? (a.scope.click(), a.scope.$apply()) : void 0
					}
				}
			}, h.prototype.watchDestroy = function (a) {
				return a.$on(&quot;$destroy&quot;, this.destroy)
			}, h
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;PolylineChildModel&quot;, [&quot;BaseObject&quot;, &quot;Logger&quot;, &quot;$timeout&quot;, &quot;array-sync&quot;, &quot;GmapUtil&quot;, &quot;EventsHelper&quot;, function (b, d, e, f, g, h) {
		var i;
		return i = function (b) {
			function e(b, c, e, g, h) {
				var i = this;
				this.scope = b, this.attrs = c, this.map = e, this.defaults = g, this.model = h, this.clean = a(this.clean, this), this.buildOpts = a(this.buildOpts, this), b.$watch(&quot;path&quot;, function (a, c) {
					var d;
					return _.isEqual(a, c) &amp;&amp; i.polyline || (d = i.convertPathPoints(b.path), d.length &gt; 0 &amp;&amp; (i.polyline = new google.maps.Polyline(i.buildOpts(d))), !i.polyline) ? void 0 : (b.fit &amp;&amp; i.extendMapBounds(e, d), f(i.polyline.getPath(), b, &quot;path&quot;, function (a) {
						return b.fit ? i.extendMapBounds(e, a) : void 0
					}), i.listeners = i.model ? i.setEvents(i.polyline, b, i.model) : i.setEvents(i.polyline, b, b))
				}), !b[&quot;static&quot;] &amp;&amp; angular.isDefined(b.editable) &amp;&amp; b.$watch(&quot;editable&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setEditable(a) : void 0
				}), angular.isDefined(b.draggable) &amp;&amp; b.$watch(&quot;draggable&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setDraggable(a) : void 0
				}), angular.isDefined(b.visible) &amp;&amp; b.$watch(&quot;visible&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setVisible(a) : void 0
				}), angular.isDefined(b.geodesic) &amp;&amp; b.$watch(&quot;geodesic&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setOptions(i.buildOpts(i.polyline.getPath())) : void 0
				}), angular.isDefined(b.stroke) &amp;&amp; angular.isDefined(b.stroke.weight) &amp;&amp; b.$watch(&quot;stroke.weight&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setOptions(i.buildOpts(i.polyline.getPath())) : void 0
				}), angular.isDefined(b.stroke) &amp;&amp; angular.isDefined(b.stroke.color) &amp;&amp; b.$watch(&quot;stroke.color&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setOptions(i.buildOpts(i.polyline.getPath())) : void 0
				}), angular.isDefined(b.stroke) &amp;&amp; angular.isDefined(b.stroke.opacity) &amp;&amp; b.$watch(&quot;stroke.opacity&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setOptions(i.buildOpts(i.polyline.getPath())) : void 0
				}), angular.isDefined(b.icons) &amp;&amp; b.$watch(&quot;icons&quot;, function (a, b) {
					var c;
					return a !== b &amp;&amp; null != (c = i.polyline) ? c.setOptions(i.buildOpts(i.polyline.getPath())) : void 0
				}), b.$on(&quot;$destroy&quot;, function () {
					return i.clean(), i.scope = null
				}), d.info(this)
			}

			return c(e, b), e.include(g), e.include(h), e.prototype.buildOpts = function (a) {
				var b, c = this;
				return b = angular.extend({}, this.defaults, {
					map: this.map,
					path: a,
					icons: this.scope.icons,
					strokeColor: this.scope.stroke &amp;&amp; this.scope.stroke.color,
					strokeOpacity: this.scope.stroke &amp;&amp; this.scope.stroke.opacity,
					strokeWeight: this.scope.stroke &amp;&amp; this.scope.stroke.weight
				}), angular.forEach({
					clickable: !0,
					draggable: !1,
					editable: !1,
					geodesic: !1,
					visible: !0,
					&quot;static&quot;: !1,
					fit: !1
				}, function (a, d) {
					return b[d] = angular.isUndefined(c.scope[d]) || null === c.scope[d] ? a : c.scope[d]
				}), b[&quot;static&quot;] &amp;&amp; (b.editable = !1), b
			}, e.prototype.clean = function () {
				var a;
				return this.removeEvents(this.listeners), this.polyline.setMap(null), this.polyline = null, a ? (a(), a = null) : void 0
			}, e.prototype.destroy = function () {
				return this.scope.$destroy()
			}, e
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.child&quot;).factory(&quot;WindowChildModel&quot;, [&quot;BaseObject&quot;, &quot;GmapUtil&quot;, &quot;Logger&quot;, &quot;$compile&quot;, &quot;$http&quot;, &quot;$templateCache&quot;, function (b, d, e, f, g, h) {
		var i;
		return i = function (b) {
			function i(b, c, d, f, g, h, i, j, k) {
				var l = this;
				this.model = b, this.scope = c, this.opts = d, this.isIconVisibleOnClick = f, this.mapCtrl = g, this.markerCtrl = h, this.element = i, this.needToManualDestroy = null != j ? j : !1, this.markerIsVisibleAfterWindowClose = null != k ? k : !0, this.destroy = a(this.destroy, this), this.remove = a(this.remove, this), this.hideWindow = a(this.hideWindow, this), this.getLatestPosition = a(this.getLatestPosition, this), this.showWindow = a(this.showWindow, this), this.handleClick = a(this.handleClick, this), this.watchOptions = a(this.watchOptions, this), this.watchCoords = a(this.watchCoords, this), this.watchShow = a(this.watchShow, this), this.getGWin = a(this.getGWin, this), this.createGWin = a(this.createGWin, this), this.watchElement = a(this.watchElement, this), this.googleMapsHandles = [], this.$log = e, this.createGWin(), null != this.markerCtrl &amp;&amp; this.markerCtrl.setClickable(!0), this.watchElement(), this.watchOptions(), this.watchShow(), this.watchCoords(), this.scope.$on(&quot;$destroy&quot;, function () {
					return l.destroy()
				}), this.$log.info(this)
			}

			return c(i, b), i.include(d), i.prototype.watchElement = function () {
				var a = this;
				return this.scope.$watch(function () {
					var b;
					if (a.element &amp;&amp; a.html)return a.html !== a.element.html() &amp;&amp; a.gWin ? (null != (b = a.opts) &amp;&amp; (b.content = void 0), a.remove(), a.createGWin(), a.showHide()) : void 0
				})
			}, i.prototype.createGWin = function () {
				var a, b, c = this;
				return null == this.gWin &amp;&amp; (a = {}, null != this.opts &amp;&amp; (this.scope.coords &amp;&amp; (this.opts.position = this.getCoords(this.scope.coords)), a = this.opts), this.element &amp;&amp; (this.html = _.isObject(this.element) ? this.element.html() : this.element), b = this.scope.options ? this.scope.options : a, this.opts = this.createWindowOptions(this.markerCtrl, this.scope, this.html, b)), null == this.opts || this.gWin ? void 0 : (this.gWin = this.opts.boxClass &amp;&amp; window.InfoBox &amp;&amp; &quot;function&quot; == typeof window.InfoBox ? new window.InfoBox(this.opts) : new google.maps.InfoWindow(this.opts), this.gWin &amp;&amp; this.handleClick(), this.googleMapsHandles.push(google.maps.event.addListener(this.gWin, &quot;closeclick&quot;, function () {
					return c.markerCtrl &amp;&amp; (c.markerCtrl.setAnimation(c.oldMarkerAnimation), c.markerIsVisibleAfterWindowClose &amp;&amp; _.delay(function () {
						return c.markerCtrl.setVisible(!1), c.markerCtrl.setVisible(c.markerIsVisibleAfterWindowClose)
					}, 250)), c.gWin.isOpen(!1), null != c.scope.closeClick ? c.scope.closeClick() : void 0
				})))
			}, i.prototype.getGWin = function () {
				return this.gWin
			}, i.prototype.watchShow = function () {
				var a = this;
				return this.scope.$watch(&quot;show&quot;, function (b, c) {
					return b !== c ? b ? a.showWindow() : a.hideWindow() : null != a.gWin &amp;&amp; b &amp;&amp; !a.gWin.getMap() ? a.showWindow() : void 0
				}, !0)
			}, i.prototype.watchCoords = function () {
				var a, b = this;
				return a = null != this.markerCtrl ? this.scope.$parent : this.scope, a.$watch(&quot;coords&quot;, function (a, c) {
					var d;
					if (a !== c) {
						if (null == a)return b.hideWindow();
						if (!b.validateCoords(a))return void b.$log.error(&quot;WindowChildMarker cannot render marker as scope.coords as no position on marker: &quot; + JSON.stringify(b.model));
						if (d = b.getCoords(a), b.gWin.setPosition(d), b.opts)return b.opts.position = d
					}
				}, !0)
			}, i.prototype.watchOptions = function () {
				var a, b = this;
				return a = null != this.markerCtrl ? this.scope.$parent : this.scope, a.$watch(&quot;options&quot;, function (a, c) {
					return a !== c &amp;&amp; (b.opts = a, null != b.gWin) ? b.gWin.setOptions(b.opts) : void 0
				}, !0)
			}, i.prototype.handleClick = function (a) {
				var b, c = this;
				return b = function () {
					var a;
					return null == c.gWin &amp;&amp; c.createGWin(), a = c.markerCtrl.getPosition(), null != c.gWin &amp;&amp; (c.gWin.setPosition(a), c.opts &amp;&amp; (c.opts.position = a), c.showWindow()), c.initialMarkerVisibility = c.markerCtrl.getVisible(), c.oldMarkerAnimation = c.markerCtrl.getAnimation(), c.markerCtrl.setVisible(c.isIconVisibleOnClick)
				}, null != this.markerCtrl ? (a &amp;&amp; b(), this.googleMapsHandles.push(google.maps.event.addListener(this.markerCtrl, &quot;click&quot;, b))) : void 0
			}, i.prototype.showWindow = function () {
				var a, b, c, d = this;
				return b = function () {
					return !d.gWin || !d.scope.show &amp;&amp; null != d.scope.show || d.gWin.isOpen() ? void 0 : d.gWin.open(d.mapCtrl)
				}, this.scope.templateUrl ? this.gWin &amp;&amp; g.get(this.scope.templateUrl, {cache: h}).then(function (a) {
					var b, c;
					return c = d.scope.$new(), angular.isDefined(d.scope.templateParameter) &amp;&amp; (c.parameter = d.scope.templateParameter), b = f(a.data)(c), d.gWin.setContent(b[0])
				}) : this.scope.template &amp;&amp; this.gWin &amp;&amp; (c = this.scope.$new(), angular.isDefined(this.scope.templateParameter) &amp;&amp; (c.parameter = this.scope.templateParameter), a = f(this.scope.template)(c), this.gWin.setContent(a[0])), b()
			}, i.prototype.showHide = function () {
				return this.scope.show || null == this.scope.show ? this.showWindow() : this.hideWindow()
			}, i.prototype.getLatestPosition = function (a) {
				return null == this.gWin || null == this.markerCtrl || a ? a ? this.gWin.setPosition(a) : void 0 : this.gWin.setPosition(this.markerCtrl.getPosition())
			}, i.prototype.hideWindow = function () {
				return null != this.gWin &amp;&amp; this.gWin.isOpen() ? this.gWin.close() : void 0
			}, i.prototype.remove = function () {
				return this.hideWindow(), _.each(this.googleMapsHandles, function (a) {
					return google.maps.event.removeListener(a)
				}), this.googleMapsHandles.length = 0, delete this.gWin, delete this.opts
			}, i.prototype.destroy = function (a) {
				var b;
				return null == a &amp;&amp; (a = !1), this.remove(), null != this.scope &amp;&amp; (this.needToManualDestroy || a) &amp;&amp; this.scope.$destroy(), b = void 0
			}, i
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;IMarkerParentModel&quot;, [&quot;ModelKey&quot;, &quot;Logger&quot;, function (b, d) {
		var e;
		return e = function (b) {
			function e(b, c, f, g, h) {
				var i, j = this;
				if (this.scope = b, this.element = c, this.attrs = f, this.map = g, this.$timeout = h, this.onDestroy = a(this.onDestroy, this), this.onWatch = a(this.onWatch, this), this.watch = a(this.watch, this), this.validateScope = a(this.validateScope, this), e.__super__.constructor.call(this, this.scope), i = this, this.$log = d, !this.validateScope(b))throw new String(&quot;Unable to construct IMarkerParentModel due to invalid scope&quot;);
				this.doClick = angular.isDefined(f.click), null != b.options &amp;&amp; (this.DEFAULTS = b.options), this.watch(&quot;coords&quot;, this.scope), this.watch(&quot;icon&quot;, this.scope), this.watch(&quot;options&quot;, this.scope), b.$on(&quot;$destroy&quot;, function () {
					return j.onDestroy(b)
				})
			}

			return c(e, b), e.prototype.DEFAULTS = {}, e.prototype.validateScope = function (a) {
				var b;
				return null == a ? (this.$log.error(this.constructor.name + &quot;: invalid scope used&quot;), !1) : (b = null != a.coords, b ? b : (this.$log.error(this.constructor.name + &quot;: no valid coords attribute found&quot;), !1))
			}, e.prototype.watch = function (a, b) {
				var c = this;
				return b.$watch(a, function (d, e) {
					return _.isEqual(d, e) ? void 0 : c.onWatch(a, b, d, e)
				}, !0)
			}, e.prototype.onWatch = function () {
				throw new String(&quot;OnWatch Not Implemented!!&quot;)
			}, e.prototype.onDestroy = function () {
				throw new String(&quot;OnDestroy Not Implemented!!&quot;)
			}, e
		}(b)
	}])
}.call(this),function () {
	var a = {}.hasOwnProperty, b = function (b, c) {
		function d() {
			this.constructor = b
		}

		for (var e in c)a.call(c, e) &amp;&amp; (b[e] = c[e]);
		return d.prototype = c.prototype, b.prototype = new d, b.__super__ = c.prototype, b
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;IWindowParentModel&quot;, [&quot;ModelKey&quot;, &quot;GmapUtil&quot;, &quot;Logger&quot;, function (a, c, d) {
		var e;
		return e = function (a) {
			function e(a, b, c, f, g, h, i, j) {
				var k;
				e.__super__.constructor.call(this, a), k = this, this.$log = d, this.$timeout = g, this.$compile = h, this.$http = i, this.$templateCache = j, null != a.options &amp;&amp; (this.DEFAULTS = a.options)
			}

			return b(e, a), e.include(c), e.prototype.DEFAULTS = {}, e
		}(a)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;LayerParentModel&quot;, [&quot;BaseObject&quot;, &quot;Logger&quot;, &quot;$timeout&quot;, function (b, d) {
		var e;
		return e = function (b) {
			function e(b, c, e, f, g, h) {
				var i = this;
				return this.scope = b, this.element = c, this.attrs = e, this.gMap = f, this.onLayerCreated = null != g ? g : void 0, this.$log = null != h ? h : d, this.createGoogleLayer = a(this.createGoogleLayer, this), null == this.attrs.type ? void this.$log.info(&quot;type attribute for the layer directive is mandatory. Layer creation aborted!!&quot;) : (this.createGoogleLayer(), this.doShow = !0, angular.isDefined(this.attrs.show) &amp;&amp; (this.doShow = this.scope.show), this.doShow &amp;&amp; null != this.gMap &amp;&amp; this.layer.setMap(this.gMap), this.scope.$watch(&quot;show&quot;, function (a, b) {
					return a !== b ? (i.doShow = a, i.layer.setMap(a ? i.gMap : null)) : void 0
				}, !0), this.scope.$watch(&quot;options&quot;, function (a, b) {
					return a !== b ? (i.layer.setMap(null), i.layer = null, i.createGoogleLayer()) : void 0
				}, !0), void this.scope.$on(&quot;$destroy&quot;, function () {
					return i.layer.setMap(null)
				}))
			}

			return c(e, b), e.prototype.createGoogleLayer = function () {
				var a;
				return this.layer = null == this.attrs.options ? void 0 === this.attrs.namespace ? new google.maps[this.attrs.type] : new google.maps[this.attrs.namespace][this.attrs.type] : void 0 === this.attrs.namespace ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options), null != this.layer &amp;&amp; null != this.onLayerCreated &amp;&amp; (a = this.onLayerCreated(this.scope, this.layer)) ? a(this.layer) : void 0
			}, e
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;MapTypeParentModel&quot;, [&quot;BaseObject&quot;, &quot;Logger&quot;, &quot;$timeout&quot;, function (b, d) {
		var e;
		return e = function (b) {
			function e(b, c, e, f, g) {
				var h = this;
				return this.scope = b, this.element = c, this.attrs = e, this.gMap = f, this.$log = null != g ? g : d, this.hideOverlay = a(this.hideOverlay, this), this.showOverlay = a(this.showOverlay, this), this.refreshMapType = a(this.refreshMapType, this), this.createMapType = a(this.createMapType, this), null == this.attrs.options ? void this.$log.info(&quot;options attribute for the map-type directive is mandatory. Map type creation aborted!!&quot;) : (this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0, this.doShow = !0, this.createMapType(), angular.isDefined(this.attrs.show) &amp;&amp; (this.doShow = this.scope.show), this.doShow &amp;&amp; null != this.gMap &amp;&amp; this.showOverlay(), this.scope.$watch(&quot;show&quot;, function (a, b) {
					return a !== b ? (h.doShow = a, a ? h.showOverlay() : h.hideOverlay()) : void 0
				}, !0), this.scope.$watch(&quot;options&quot;, function (a, b) {
					return _.isEqual(a, b) ? void 0 : h.refreshMapType()
				}, !0), angular.isDefined(this.attrs.refresh) &amp;&amp; this.scope.$watch(&quot;refresh&quot;, function (a, b) {
					return _.isEqual(a, b) ? void 0 : h.refreshMapType()
				}, !0), void this.scope.$on(&quot;$destroy&quot;, function () {
					return h.hideOverlay(), h.mapType = null
				}))
			}

			return c(e, b), e.prototype.createMapType = function () {
				if (null != this.scope.options.getTile)this.mapType = this.scope.options; else {
					if (null == this.scope.options.getTileUrl)return void this.$log.info(&quot;options should provide either getTile or getTileUrl methods. Map type creation aborted!!&quot;);
					this.mapType = new google.maps.ImageMapType(this.scope.options)
				}
				return this.attrs.id &amp;&amp; this.scope.id &amp;&amp; (this.gMap.mapTypes.set(this.scope.id, this.mapType), angular.isDefined(this.attrs.show) || (this.doShow = !1)), this.mapType.layerId = this.id
			}, e.prototype.refreshMapType = function () {
				return this.hideOverlay(), this.mapType = null, this.createMapType(), this.doShow &amp;&amp; null != this.gMap ? this.showOverlay() : void 0
			}, e.prototype.showOverlay = function () {
				return this.gMap.overlayMapTypes.push(this.mapType)
			}, e.prototype.hideOverlay = function () {
				var a, b = this;
				return a = !1, this.gMap.overlayMapTypes.forEach(function (c, d) {
					a || c.layerId !== b.id || (a = !0, b.gMap.overlayMapTypes.removeAt(d))
				})
			}, e
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;MarkerParentModel&quot;, [&quot;IMarkerParentModel&quot;, &quot;GmapUtil&quot;, &quot;EventsHelper&quot;, &quot;ModelKey&quot;, function (b, d, e) {
		var f;
		return f = function (b) {
			function f(b, c, d, e, g, h, i) {
				var j, k = this;
				this.gMarkerManager = h, this.doFit = i, this.onDestroy = a(this.onDestroy, this), this.setGMarker = a(this.setGMarker, this), this.onWatch = a(this.onWatch, this), f.__super__.constructor.call(this, b, c, d, e, g), j = this.createMarkerOptions(b.coords, b.icon, b.options, this.map), this.setGMarker(new google.maps.Marker(j)), this.listener = google.maps.event.addListener(this.scope.gMarker, &quot;click&quot;, function () {
					return k.doClick &amp;&amp; null != b.click ? k.scope.click() : void 0
				}), this.setEvents(this.scope.gMarker, b, b), this.$log.info(this)
			}

			return c(f, b), f.include(d), f.include(e), f.prototype.onWatch = function (a, b) {
				var c, d, e;
				switch (a) {
					case&quot;coords&quot;:
						if (this.validateCoords(b.coords) &amp;&amp; null != this.scope.gMarker) {
							if (d = null != (e = this.scope.gMarker) ? e.getPosition() : void 0, d.lat() === this.scope.coords.latitude &amp;&amp; this.scope.coords.longitude === d.lng())return;
							return c = this.scope.gMarker.getAnimation(), this.scope.gMarker.setMap(this.map), this.scope.gMarker.setPosition(this.getCoords(b.coords)), this.scope.gMarker.setVisible(this.validateCoords(b.coords)), this.scope.gMarker.setAnimation(c)
						}
						return this.scope.gMarker.setMap(null);
					case&quot;icon&quot;:
						if (null != b.icon &amp;&amp; this.validateCoords(b.coords) &amp;&amp; null != this.scope.gMarker)return this.scope.gMarker.setIcon(b.icon), this.scope.gMarker.setMap(null), this.scope.gMarker.setMap(this.map), this.scope.gMarker.setPosition(this.getCoords(b.coords)), this.scope.gMarker.setVisible(this.validateCoords(b.coords));
						break;
					case&quot;options&quot;:
						if (this.validateCoords(b.coords) &amp;&amp; b.options)return null != this.scope.gMarker &amp;&amp; this.scope.gMarker.setMap(null), this.setGMarker(new google.maps.Marker(this.createMarkerOptions(b.coords, b.icon, b.options, this.map)))
				}
			}, f.prototype.setGMarker = function (a) {
				var b;
				return this.scope.gMarker &amp;&amp; (b = this.gMarkerManager.remove(this.scope.gMarker, !1), delete this.scope.gMarker), this.scope.gMarker = a, this.scope.gMarker &amp;&amp; (this.scope.gMarker.key = this.scope.idKey, this.gMarkerManager.add(this.scope.gMarker, !1), this.doFit) ? this.gMarkerManager.fit() : void 0
			}, f.prototype.onDestroy = function () {
				var a;
				return this.scope.gMarker ? (this.scope.gMarker.setMap(null), google.maps.event.removeListener(this.listener), this.listener = null, this.gMarkerManager.remove(this.scope.gMarker, !1), delete this.scope.gMarker, a = void 0) : void(a = void 0)
			}, f
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;MarkersParentModel&quot;, [&quot;IMarkerParentModel&quot;, &quot;ModelsWatcher&quot;, &quot;PropMap&quot;, &quot;MarkerChildModel&quot;, &quot;ClustererMarkerManager&quot;, &quot;MarkerManager&quot;, function (b, d, e, f, g, h) {
		var i;
		return i = function (b) {
			function i(b, c, d, f, g) {
				this.onDestroy = a(this.onDestroy, this), this.newChildMarker = a(this.newChildMarker, this), this.updateChild = a(this.updateChild, this), this.pieceMeal = a(this.pieceMeal, this), this.reBuildMarkers = a(this.reBuildMarkers, this), this.createMarkersFromScratch = a(this.createMarkersFromScratch, this), this.validateScope = a(this.validateScope, this), this.onWatch = a(this.onWatch, this);
				var h, j = this;
				i.__super__.constructor.call(this, b, c, d, f, g), h = this, this.scope.markerModels = new e, this.$timeout = g, this.$log.info(this), this.doRebuildAll = null != this.scope.doRebuildAll ? this.scope.doRebuildAll : !1, this.setIdKey(b), this.scope.$watch(&quot;doRebuildAll&quot;, function (a, b) {
					return a !== b ? j.doRebuildAll = a : void 0
				}), this.watch(&quot;models&quot;, b), this.watch(&quot;doCluster&quot;, b), this.watch(&quot;clusterOptions&quot;, b), this.watch(&quot;clusterEvents&quot;, b), this.watch(&quot;fit&quot;, b), this.watch(&quot;idKey&quot;, b), this.gMarkerManager = void 0, this.createMarkersFromScratch(b)
			}

			return c(i, b), i.include(d), i.prototype.onWatch = function (a, b, c, d) {
				return &quot;idKey&quot; === a &amp;&amp; c !== d &amp;&amp; (this.idKey = c), this.doRebuildAll ? this.reBuildMarkers(b) : this.pieceMeal(b)
			}, i.prototype.validateScope = function (a) {
				var b;
				return b = angular.isUndefined(a.models) || void 0 === a.models, b &amp;&amp; this.$log.error(this.constructor.name + &quot;: no valid models attribute found&quot;), i.__super__.validateScope.call(this, a) || b
			}, i.prototype.createMarkersFromScratch = function (a) {
				var b = this;
				return a.doCluster ? (a.clusterEvents &amp;&amp; (this.clusterInternalOptions = _.once(function () {
					var c, d, e, f;
					return c = b, b.origClusterEvents ? void 0 : (b.origClusterEvents = {
						click: null != (d = a.clusterEvents) ? d.click : void 0,
						mouseout: null != (e = a.clusterEvents) ? e.mouseout : void 0,
						mouseover: null != (f = a.clusterEvents) ? f.mouseover : void 0
					}, _.extend(a.clusterEvents, {
						click: function (a) {
							return c.maybeExecMappedEvent(a, &quot;click&quot;)
						}, mouseout: function (a) {
							return c.maybeExecMappedEvent(a, &quot;mouseout&quot;)
						}, mouseover: function (a) {
							return c.maybeExecMappedEvent(a, &quot;mouseover&quot;)
						}
					}))
				})()), a.clusterOptions || a.clusterEvents ? void 0 === this.gMarkerManager ? this.gMarkerManager = new g(this.map, void 0, a.clusterOptions, this.clusterInternalOptions) : this.gMarkerManager.opt_options !== a.clusterOptions &amp;&amp; (this.gMarkerManager = new g(this.map, void 0, a.clusterOptions, this.clusterInternalOptions)) : this.gMarkerManager = new g(this.map)) : this.gMarkerManager = new h(this.map), _async.each(a.models, function (c) {
					return b.newChildMarker(c, a)
				}, function () {
					return b.gMarkerManager.draw(), a.fit ? b.gMarkerManager.fit() : void 0
				})
			}, i.prototype.reBuildMarkers = function (a) {
				return a.doRebuild || void 0 === a.doRebuild ? (this.onDestroy(a), this.createMarkersFromScratch(a)) : void 0
			}, i.prototype.pieceMeal = function (a) {
				var b = this;
				return null != this.scope.models &amp;&amp; this.scope.models.length &gt; 0 &amp;&amp; this.scope.markerModels.length &gt; 0 ? this.figureOutState(this.idKey, a, this.scope.markerModels, this.modelKeyComparison, function (c) {
					var d;
					return d = c, _async.each(d.removals, function (a) {
						return null != a ? (null != a.destroy &amp;&amp; a.destroy(), b.scope.markerModels.remove(a.id)) : void 0
					}, function () {
						return _async.each(d.adds, function (c) {
							return b.newChildMarker(c, a)
						}, function () {
							return _async.each(d.updates, function (a) {
								return b.updateChild(a.child, a.model)
							}, function () {
								return d.adds.length &gt; 0 || d.removals.length &gt; 0 || d.updates.length &gt; 0 ? (b.gMarkerManager.draw(), a.markerModels = b.scope.markerModels) : void 0
							})
						})
					})
				}) : this.reBuildMarkers(a)
			}, i.prototype.updateChild = function (a, b) {
				return null == b[this.idKey] ? void this.$log.error(&quot;Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.&quot;) : a.setMyScope(b, a.model, !1)
			}, i.prototype.newChildMarker = function (a, b) {
				var c, d;
				return null == a[this.idKey] ? void this.$log.error(&quot;Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.&quot;) : (this.$log.info(&quot;child&quot;, c, &quot;markers&quot;, this.scope.markerModels), c = new f(a, b, this.map, this.$timeout, this.DEFAULTS, this.doClick, this.gMarkerManager, this.idKey, d = !1), this.scope.markerModels.put(a[this.idKey], c), c)
			}, i.prototype.onDestroy = function () {
				return _.each(this.scope.markerModels.values(), function (a) {
					return null != a ? a.destroy() : void 0
				}), delete this.scope.markerModels, this.scope.markerModels = new e, null != this.gMarkerManager ? this.gMarkerManager.clear() : void 0
			}, i.prototype.maybeExecMappedEvent = function (a, b) {
				var c, d;
				return _.isFunction(null != (d = this.scope.clusterEvents) ? d[b] : void 0) &amp;&amp; (c = this.mapClusterToMarkerModels(a), this.origClusterEvents[b]) ? this.origClusterEvents[b](c.cluster, c.mapped) : void 0
			}, i.prototype.mapClusterToMarkerModels = function (a) {
				var b, c, d = this;
				return b = a.getMarkers().values(), c = b.map(function (a) {
					return d.scope.markerModels[a.key].model
				}), {cluster: a, mapped: c}
			}, i
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;PolylinesParentModel&quot;, [&quot;$timeout&quot;, &quot;Logger&quot;, &quot;ModelKey&quot;, &quot;ModelsWatcher&quot;, &quot;PropMap&quot;, &quot;PolylineChildModel&quot;, function (b, d, e, f, g, h) {
		var i;
		return i = function (b) {
			function e(b, c, f, h, i) {
				var j, k = this;
				this.scope = b, this.element = c, this.attrs = f, this.gMap = h, this.defaults = i, this.modelKeyComparison = a(this.modelKeyComparison, this), this.setChildScope = a(this.setChildScope, this), this.createChild = a(this.createChild, this), this.pieceMeal = a(this.pieceMeal, this), this.createAllNew = a(this.createAllNew, this), this.watchIdKey = a(this.watchIdKey, this), this.createChildScopes = a(this.createChildScopes, this), this.watchOurScope = a(this.watchOurScope, this), this.watchDestroy = a(this.watchDestroy, this), this.rebuildAll = a(this.rebuildAll, this), this.doINeedToWipe = a(this.doINeedToWipe, this), this.watchModels = a(this.watchModels, this), this.watch = a(this.watch, this), e.__super__.constructor.call(this, b), j = this, this.$log = d, this.plurals = new g, this.scopePropNames = [&quot;path&quot;, &quot;stroke&quot;, &quot;clickable&quot;, &quot;draggable&quot;, &quot;editable&quot;, &quot;geodesic&quot;, &quot;icons&quot;, &quot;visible&quot;], _.each(this.scopePropNames, function (a) {
					return k[a + &quot;Key&quot;] = void 0
				}), this.models = void 0, this.firstTime = !0, this.$log.info(this), this.watchOurScope(b), this.createChildScopes()
			}

			return c(e, b), e.include(f), e.prototype.watch = function (a, b, c) {
				var d = this;
				return a.$watch(b, function (a, e) {
					return a !== e ? (d[c] = &quot;function&quot; == typeof a ? a() : a, _async.each(_.values(d.plurals), function (a) {
						return a.scope[b] = &quot;self&quot; === d[c] ? a : a[d[c]]
					}, function () {
					})) : void 0
				})
			}, e.prototype.watchModels = function (a) {
				var b = this;
				return a.$watch(&quot;models&quot;, function (c, d) {
					return _.isEqual(c, d) ? void 0 : b.doINeedToWipe(c) ? b.rebuildAll(a, !0, !0) : b.createChildScopes(!1)
				}, !0)
			}, e.prototype.doINeedToWipe = function (a) {
				var b;
				return b = null != a ? 0 === a.length : !0, this.plurals.length &gt; 0 &amp;&amp; b
			}, e.prototype.rebuildAll = function (a, b, c) {
				var d = this;
				return _async.each(this.plurals.values(), function (a) {
					return a.destroy()
				}, function () {
					return c &amp;&amp; delete d.plurals, d.plurals = new g, b ? d.createChildScopes() : void 0
				})
			}, e.prototype.watchDestroy = function (a) {
				var b = this;
				return a.$on(&quot;$destroy&quot;, function () {
					return b.rebuildAll(a, !1, !0)
				})
			}, e.prototype.watchOurScope = function (a) {
				var b = this;
				return _.each(this.scopePropNames, function (c) {
					var d;
					return d = c + &quot;Key&quot;, b[d] = &quot;function&quot; == typeof a[c] ? a[c]() : a[c], b.watch(a, c, d)
				})
			}, e.prototype.createChildScopes = function (a) {
				return null == a &amp;&amp; (a = !0), angular.isUndefined(this.scope.models) ? void this.$log.error(&quot;No models to create polylines from! I Need direct models!&quot;) : null != this.gMap &amp;&amp; null != this.scope.models ? (this.watchIdKey(this.scope), a ? this.createAllNew(this.scope, !1) : this.pieceMeal(this.scope, !1)) : void 0
			}, e.prototype.watchIdKey = function (a) {
				var b = this;
				return this.setIdKey(a), a.$watch(&quot;idKey&quot;, function (c, d) {
					return c !== d &amp;&amp; null == c ? (b.idKey = c, b.rebuildAll(a, !0, !0)) : void 0
				})
			}, e.prototype.createAllNew = function (a, b) {
				var c = this;
				return null == b &amp;&amp; (b = !1), this.models = a.models, this.firstTime &amp;&amp; (this.watchModels(a), this.watchDestroy(a)), _async.each(a.models, function (a) {
					return c.createChild(a, c.gMap)
				}, function () {
					return c.firstTime = !1
				})
			}, e.prototype.pieceMeal = function (a, b) {
				var c = this;
				return null == b &amp;&amp; (b = !0), this.models = a.models, null != a &amp;&amp; null != a.models &amp;&amp; a.models.length &gt; 0 &amp;&amp; this.plurals.length &gt; 0 ? this.figureOutState(this.idKey, a, this.plurals, this.modelKeyComparison, function (a) {
					var b;
					return b = a, _async.each(b.removals, function (a) {
						var b;
						return b = c.plurals[a], null != b ? (b.destroy(), c.plurals.remove(a)) : void 0
					}, function () {
						return _async.each(b.adds, function (a) {
							return c.createChild(a, c.gMap)
						}, function () {
						})
					})
				}) : this.rebuildAll(this.scope, !0, !0)
			}, e.prototype.createChild = function (a, b) {
				var c, d, e = this;
				return d = this.scope.$new(!1), this.setChildScope(d, a), d.$watch(&quot;model&quot;, function (a, b) {
					return a !== b ? e.setChildScope(d, a) : void 0
				}, !0), d[&quot;static&quot;] = this.scope[&quot;static&quot;], c = new h(d, this.attrs, b, this.defaults, a), null == a[this.idKey] ? void this.$log.error(&quot;Polyline model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.&quot;) : (this.plurals.put(a[this.idKey], c), c)
			}, e.prototype.setChildScope = function (a, b) {
				var c = this;
				return _.each(this.scopePropNames, function (d) {
					var e, f;
					return e = d + &quot;Key&quot;, f = &quot;self&quot; === c[e] ? b : b[c[e]], f !== a[d] ? a[d] = f : void 0
				}), a.model = b
			}, e.prototype.modelKeyComparison = function (a, b) {
				return _.isEqual(this.evalModelHandle(a, this.scope.path), this.evalModelHandle(b, this.scope.path))
			}, e
		}(e)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api.models.parent&quot;).factory(&quot;WindowsParentModel&quot;, [&quot;IWindowParentModel&quot;, &quot;ModelsWatcher&quot;, &quot;PropMap&quot;, &quot;WindowChildModel&quot;, &quot;Linked&quot;, function (b, d, e, f, g) {
		var h;
		return h = function (b) {
			function h(b, c, d, f, i, j, k, l, m) {
				var n, o, p = this;
				this.$interpolate = m, this.interpolateContent = a(this.interpolateContent, this), this.setChildScope = a(this.setChildScope, this), this.createWindow = a(this.createWindow, this), this.setContentKeys = a(this.setContentKeys, this), this.pieceMealWindows = a(this.pieceMealWindows, this), this.createAllNewWindows = a(this.createAllNewWindows, this), this.watchIdKey = a(this.watchIdKey, this), this.createChildScopesWindows = a(this.createChildScopesWindows, this), this.watchOurScope = a(this.watchOurScope, this), this.watchDestroy = a(this.watchDestroy, this), this.rebuildAll = a(this.rebuildAll, this), this.doINeedToWipe = a(this.doINeedToWipe, this), this.watchModels = a(this.watchModels, this), this.watch = a(this.watch, this), this.go = a(this.go, this), h.__super__.constructor.call(this, b, c, d, f, i, j, k, l), o = this, this.windows = new e, this.scopePropNames = [&quot;show&quot;, &quot;coords&quot;, &quot;templateUrl&quot;, &quot;templateParameter&quot;, &quot;isIconVisibleOnClick&quot;, &quot;closeClick&quot;], _.each(this.scopePropNames, function (a) {
					return p[a + &quot;Key&quot;] = void 0
				}), this.linked = new g(b, c, d, f), this.models = void 0, this.contentKeys = void 0, this.isIconVisibleOnClick = void 0, this.firstTime = !0, this.$log.info(o), this.parentScope = void 0, n = f[0].getScope(), n.deferred.promise.then(function (a) {
					var c;
					return p.gMap = a, c = f.length &gt; 1 &amp;&amp; null != f[1] ? f[1] : void 0, c ? c.getScope().deferred.promise.then(function () {
						return p.markerScope = c.getScope(), p.go(b)
					}) : void p.go(b)
				})
			}

			return c(h, b), h.include(d), h.prototype.go = function (a) {
				var b = this;
				return this.watchOurScope(a), this.doRebuildAll = null != this.scope.doRebuildAll ? this.scope.doRebuildAll : !1, a.$watch(&quot;doRebuildAll&quot;, function (a, c) {
					return a !== c ? b.doRebuildAll = a : void 0
				}), this.createChildScopesWindows()
			}, h.prototype.watch = function (a, b, c) {
				var d = this;
				return a.$watch(b, function (a, e) {
					return a !== e ? (d[c] = &quot;function&quot; == typeof a ? a() : a, _async.each(_.values(d.windows), function (a) {
						return a.scope[b] = &quot;self&quot; === d[c] ? a : a[d[c]]
					}, function () {
					})) : void 0
				})
			}, h.prototype.watchModels = function (a) {
				var b = this;
				return a.$watch(&quot;models&quot;, function (c, d) {
					return _.isEqual(c, d) ? void 0 : b.doRebuildAll || b.doINeedToWipe(c) ? b.rebuildAll(a, !0, !0) : b.createChildScopesWindows(!1)
				})
			}, h.prototype.doINeedToWipe = function (a) {
				var b;
				return b = null != a ? 0 === a.length : !0, this.windows.length &gt; 0 &amp;&amp; b
			}, h.prototype.rebuildAll = function (a, b, c) {
				var d = this;
				return _async.each(this.windows.values(), function (a) {
					return a.destroy()
				}, function () {
					return c &amp;&amp; delete d.windows, d.windows = new e, b ? d.createChildScopesWindows() : void 0
				})
			}, h.prototype.watchDestroy = function (a) {
				var b = this;
				return a.$on(&quot;$destroy&quot;, function () {
					return b.rebuildAll(a, !1, !0)
				})
			}, h.prototype.watchOurScope = function (a) {
				var b = this;
				return _.each(this.scopePropNames, function (c) {
					var d;
					return d = c + &quot;Key&quot;, b[d] = &quot;function&quot; == typeof a[c] ? a[c]() : a[c], b.watch(a, c, d)
				})
			}, h.prototype.createChildScopesWindows = function (a) {
				var b, c;
				return null == a &amp;&amp; (a = !0), this.isIconVisibleOnClick = !0, angular.isDefined(this.linked.attrs.isiconvisibleonclick) &amp;&amp; (this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick), b = this.markerScope, c = angular.isUndefined(this.linked.scope.models), !c || void 0 !== b &amp;&amp; void 0 !== b.markerModels &amp;&amp; void 0 !== b.models ? null != this.gMap ? null != this.linked.scope.models ? (this.watchIdKey(this.linked.scope), a ? this.createAllNewWindows(this.linked.scope, !1) : this.pieceMealWindows(this.linked.scope, !1)) : (this.parentScope = b, this.watchIdKey(this.parentScope), a ? this.createAllNewWindows(b, !0, &quot;markerModels&quot;, !1) : this.pieceMealWindows(b, !0, &quot;markerModels&quot;, !1)) : void 0 : void this.$log.error(&quot;No models to create windows from! Need direct models or models derrived from markers!&quot;)
			}, h.prototype.watchIdKey = function (a) {
				var b = this;
				return this.setIdKey(a), a.$watch(&quot;idKey&quot;, function (c, d) {
					return c !== d &amp;&amp; null == c ? (b.idKey = c, b.rebuildAll(a, !0, !0)) : void 0
				})
			}, h.prototype.createAllNewWindows = function (a, b, c, d) {
				var e = this;
				return null == c &amp;&amp; (c = &quot;models&quot;), null == d &amp;&amp; (d = !1), this.models = a.models, this.firstTime &amp;&amp; (this.watchModels(a), this.watchDestroy(a)), this.setContentKeys(a.models), _async.each(a.models, function (d) {
					var f;
					return f = b ? a[c][[d[e.idKey]]].gMarker : void 0, e.createWindow(d, f, e.gMap)
				}, function () {
					return e.firstTime = !1
				})
			}, h.prototype.pieceMealWindows = function (a, b, c, d) {
				var e = this;
				return null == c &amp;&amp; (c = &quot;models&quot;), null == d &amp;&amp; (d = !0), this.models = a.models, null != a &amp;&amp; null != a.models &amp;&amp; a.models.length &gt; 0 &amp;&amp; this.windows.length &gt; 0 ? this.figureOutState(this.idKey, a, this.windows, this.modelKeyComparison, function (b) {
					var d;
					return d = b, _async.each(d.removals, function (a) {
						return null != a ? (null != a.destroy &amp;&amp; a.destroy(), e.windows.remove(a.id)) : void 0
					}, function () {
						return _async.each(d.adds, function (b) {
							var d;
							return d = a[c][b[e.idKey]].gMarker, e.createWindow(b, d, e.gMap)
						}, function () {
						})
					})
				}) : this.rebuildAll(this.scope, !0, !0)
			}, h.prototype.setContentKeys = function (a) {
				return a.length &gt; 0 ? this.contentKeys = Object.keys(a[0]) : void 0
			}, h.prototype.createWindow = function (a, b, c) {
				var d, e, g, h, i = this;
				return e = this.linked.scope.$new(!1), this.setChildScope(e, a), e.$watch(&quot;model&quot;, function (a, b) {
					return a !== b &amp;&amp; (i.setChildScope(e, a), i.markerScope) ? i.windows[a[i.idKey]].markerCtrl = i.markerScope.markerModels[a[i.idKey]].gMarker : void 0
				}, !0), g = {
					html: function () {
						return i.interpolateContent(i.linked.element.html(), a)
					}
				}, h = this.createWindowOptions(b, e, g.html(), this.DEFAULTS), d = new f(a, e, h, this.isIconVisibleOnClick, c, b, g, !1, !0), null == a[this.idKey] ? void this.$log.error(&quot;Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.&quot;) : (this.windows.put(a[this.idKey], d), d)
			}, h.prototype.setChildScope = function (a, b) {
				var c = this;
				return _.each(this.scopePropNames, function (d) {
					var e, f;
					return e = d + &quot;Key&quot;, f = &quot;self&quot; === c[e] ? b : b[c[e]], f !== a[d] ? a[d] = f : void 0
				}), a.model = b
			}, h.prototype.interpolateContent = function (a, b) {
				var c, d, e, f, g, h;
				if (void 0 !== this.contentKeys &amp;&amp; 0 !== this.contentKeys.length) {
					for (c = this.$interpolate(a), d = {}, h = this.contentKeys, f = 0, g = h.length; g &gt; f; f++)e = h[f], d[e] = b[e];
					return c(d)
				}
			}, h
		}(b)
	}])
}.call(this),function () {
	var a = {}.hasOwnProperty, b = function (b, c) {
		function d() {
			this.constructor = b
		}

		for (var e in c)a.call(c, e) &amp;&amp; (b[e] = c[e]);
		return d.prototype = c.prototype, b.prototype = new d, b.__super__ = c.prototype, b
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Control&quot;, [&quot;IControl&quot;, &quot;$http&quot;, &quot;$templateCache&quot;, &quot;$compile&quot;, &quot;$controller&quot;, function (a, c, d, e, f) {
		var g;
		return g = function (g) {
			function h() {
				var a;
				h.__super__.constructor.call(this), a = this
			}

			return b(h, g), h.prototype.link = function (b, g, h, i) {
				var j, k, l = this;
				return angular.isUndefined(b.template) ? void this.$log.error(&quot;mapControl: could not find a valid template property&quot;) : (j = angular.isDefined(b.index &amp;&amp; !isNaN(parseInt(b.index))) ? parseInt(b.index) : void 0, k = angular.isDefined(b.position) ? b.position.toUpperCase().replace(/-/g, &quot;_&quot;) : &quot;TOP_CENTER&quot;, google.maps.ControlPosition[k] ? a.mapPromise(b, i).then(function (a) {
					var g, h;
					return g = void 0, h = angular.element(&quot;&lt;div&gt;&lt;/div&gt;&quot;), c.get(b.template, {cache: d}).success(function (a) {
						var c, d;
						return d = b.$new(), h.append(a), j &amp;&amp; (h[0].index = j), angular.isDefined(b.controller) &amp;&amp; (c = f(b.controller, {$scope: d}), h.children().data(&quot;$ngControllerController&quot;, c)), g = e(h.contents())(d)
					}).error(function () {
						return l.$log.error(&quot;mapControl: template could not be found&quot;)
					}).then(function () {
						return a.controls[google.maps.ControlPosition[k]].push(g[0])
					})
				}) : void this.$log.error(&quot;mapControl: invalid position property&quot;))
			}, h
		}(a)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;FreeDrawPolygons&quot;, [&quot;Logger&quot;, &quot;BaseObject&quot;, &quot;CtrlHandle&quot;, &quot;DrawFreeHandChildModel&quot;, function (b, d, e, f) {
		var g, h;
		return g = function (d) {
			function g() {
				return this.link = a(this.link, this), h = g.__super__.constructor.apply(this, arguments)
			}

			return c(g, d), g.include(e), g.prototype.restrict = &quot;EA&quot;, g.prototype.replace = !0, g.prototype.require = &quot;^googleMap&quot;, g.prototype.scope = {
				polygons: &quot;=&quot;,
				draw: &quot;=&quot;
			}, g.prototype.link = function (a, c, d, e) {
				return this.mapPromise(a, e).then(function (c) {
					var d, e;
					return a.polygons ? _.isArray(a.polygons) ? (d = new f(c, a.originalMapOpts), e = void 0, a.draw = function () {
						return &quot;function&quot; == typeof e &amp;&amp; e(), d.engage(a.polygons).then(function () {
							var b;
							return b = !0, e = a.$watch(&quot;polygons&quot;, function (a, c) {
								var d;
								return b ? void(b = !1) : (d = _.differenceObjects(c, a), d.forEach(function (a) {
									return a.setMap(null)
								}))
							})
						})
					}) : b.error(&quot;Free Draw Polygons must be of type Array!&quot;) : b.error(&quot;No polygons to bind to!&quot;)
				})
			}, g
		}(d)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;IControl&quot;, [&quot;BaseObject&quot;, &quot;Logger&quot;, &quot;CtrlHandle&quot;, function (b, d, e) {
		var f;
		return f = function (b) {
			function f() {
				this.link = a(this.link, this), this.restrict = &quot;EA&quot;, this.replace = !0, this.require = &quot;^googleMap&quot;, this.scope = {
					template: &quot;@template&quot;,
					position: &quot;@position&quot;,
					controller: &quot;@controller&quot;,
					index: &quot;@index&quot;
				}, this.$log = d
			}

			return c(f, b), f.extend(e), f.prototype.link = function () {
				throw new Exception(&quot;Not implemented!!&quot;)
			}, f
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;ILabel&quot;, [&quot;BaseObject&quot;, &quot;Logger&quot;, function (b, d) {
		var e;
		return e = function (b) {
			function e(b) {
				this.link = a(this.link, this);
				var c;
				c = this, this.restrict = &quot;EMA&quot;, this.replace = !0, this.template = void 0, this.require = void 0, this.transclude = !0, this.priority = -100, this.scope = {
					labelContent: &quot;=content&quot;,
					labelAnchor: &quot;@anchor&quot;,
					labelClass: &quot;@class&quot;,
					labelStyle: &quot;=style&quot;
				}, this.$log = d, this.$timeout = b
			}

			return c(e, b), e.prototype.link = function () {
				throw new Exception(&quot;Not Implemented!!&quot;)
			}, e
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;IMarker&quot;, [&quot;Logger&quot;, &quot;BaseObject&quot;, &quot;CtrlHandle&quot;, function (b, d, e) {
		var f;
		return f = function (d) {
			function f() {
				this.link = a(this.link, this), this.$log = b, this.restrict = &quot;EMA&quot;, this.require = &quot;^googleMap&quot;, this.priority = -1, this.transclude = !0, this.replace = !0, this.scope = {
					coords: &quot;=coords&quot;,
					icon: &quot;=icon&quot;,
					click: &quot;&amp;click&quot;,
					options: &quot;=options&quot;,
					events: &quot;=events&quot;,
					fit: &quot;=fit&quot;,
					idKey: &quot;=idkey&quot;,
					control: &quot;=control&quot;
				}
			}

			return c(f, d), f.extend(e), f.prototype.link = function (a, b, c, d) {
				if (!d)throw new Error(&quot;No Map Control! Marker Directive Must be inside the map!&quot;)
			}, f
		}(d)
	}])
}.call(this),function () {
	var a = {}.hasOwnProperty, b = function (b, c) {
		function d() {
			this.constructor = b
		}

		for (var e in c)a.call(c, e) &amp;&amp; (b[e] = c[e]);
		return d.prototype = c.prototype, b.prototype = new d, b.__super__ = c.prototype, b
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;IPolyline&quot;, [&quot;GmapUtil&quot;, &quot;BaseObject&quot;, &quot;Logger&quot;, &quot;CtrlHandle&quot;, function (a, c, d, e) {
		var f;
		return f = function (c) {
			function f() {
			}

			return b(f, c), f.include(a), f.extend(e), f.prototype.restrict = &quot;EA&quot;, f.prototype.replace = !0, f.prototype.require = &quot;^googleMap&quot;, f.prototype.scope = {
				path: &quot;=&quot;,
				stroke: &quot;=&quot;,
				clickable: &quot;=&quot;,
				draggable: &quot;=&quot;,
				editable: &quot;=&quot;,
				geodesic: &quot;=&quot;,
				icons: &quot;=&quot;,
				visible: &quot;=&quot;,
				&quot;static&quot;: &quot;=&quot;,
				fit: &quot;=&quot;,
				events: &quot;=&quot;
			}, f.prototype.DEFAULTS = {}, f.prototype.$log = d, f
		}(c)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;IWindow&quot;, [&quot;BaseObject&quot;, &quot;ChildEvents&quot;, &quot;Logger&quot;, function (b, d, e) {
		var f;
		return f = function (b) {
			function f(b, c, d, f) {
				this.$timeout = b, this.$compile = c, this.$http = d, this.$templateCache = f, this.link = a(this.link, this), this.restrict = &quot;EMA&quot;, this.template = void 0, this.transclude = !0, this.priority = -100, this.require = void 0, this.replace = !0, this.scope = {
					coords: &quot;=coords&quot;,
					show: &quot;=show&quot;,
					templateUrl: &quot;=templateurl&quot;,
					template: &quot;=template&quot;,
					templateParameter: &quot;=templateparameter&quot;,
					isIconVisibleOnClick: &quot;=isiconvisibleonclick&quot;,
					closeClick: &quot;&amp;closeclick&quot;,
					options: &quot;=options&quot;,
					control: &quot;=control&quot;
				}, this.$log = e
			}

			return c(f, b), f.include(d), f.prototype.link = function () {
				throw new Exception(&quot;Not Implemented!!&quot;)
			}, f
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Map&quot;, [&quot;$timeout&quot;, &quot;$q&quot;, &quot;Logger&quot;, &quot;GmapUtil&quot;, &quot;BaseObject&quot;, &quot;ExtendGWin&quot;, &quot;CtrlHandle&quot;, &quot;IsReady&quot;.ns(), &quot;uuid&quot;.ns(), function (b, d, e, f, g, h, i, j, k) {
		&quot;use strict&quot;;
		var l, m, n;
		return l = e, m = {mapTypeId: google.maps.MapTypeId.ROADMAP}, n = function (b) {
			function d() {
				this.link = a(this.link, this);
				var b, c;
				b = function (a) {
					var b;
					return b = i.handle(a), a.ctrlType = &quot;Map&quot;, a.deferred.promise.then(function () {
						return h.init()
					}), b.getMap = function () {
						return a.map
					}, _.extend(this, b)
				}, this.controller = [&quot;$scope&quot;, b], c = this
			}

			return c(d, b), d.include(f), d.prototype.restrict = &quot;EMA&quot;, d.prototype.transclude = !0, d.prototype.replace = !1, d.prototype.template = &#039;&lt;div class=&quot;angular-google-map&quot;&gt;&lt;div class=&quot;angular-google-map-container&quot;&gt;&lt;/div&gt;&lt;div ng-transclude style=&quot;display: none&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#039;, d.prototype.scope = {
				center: &quot;=&quot;,
				zoom: &quot;=&quot;,
				dragging: &quot;=&quot;,
				control: &quot;=&quot;,
				windows: &quot;=&quot;,
				options: &quot;=&quot;,
				events: &quot;=&quot;,
				styles: &quot;=&quot;,
				draggable: &quot;=&quot;,
				bounds: &quot;=&quot;
			}, d.prototype.link = function (a, b, c) {
				var d, e, f, g, h, i, n, o, p, q, r, s = this;
				if (p = j.spawn(), n = function () {
						return p.deferred.resolve({instance: p.instance, map: r})
					}, !this.validateCoords(a.center))return void l.error(&quot;angular-google-maps: could not find a valid center property&quot;);
				if (!angular.isDefined(a.zoom))return void l.error(&quot;angular-google-maps: map zoom property not set&quot;);
				if (e = angular.element(b), e.addClass(&quot;angular-google-map&quot;), i = {options: {}}, c.options &amp;&amp; (i.options = a.options), c.styles &amp;&amp; (i.styles = a.styles), c.type &amp;&amp; (q = c.type.toUpperCase(), google.maps.MapTypeId.hasOwnProperty(q) ? i.mapTypeId = google.maps.MapTypeId[c.type.toUpperCase()] : l.error(&#039;angular-google-maps: invalid map type &quot;&#039; + c.type + &#039;&quot;&#039;)), h = angular.extend({}, m, i, {
						center: this.getCoords(a.center),
						draggable: null != c.draggable ? this.isTrue(a.draggable) : !0,
						zoom: a.zoom,
						bounds: a.bounds
					}), r = new google.maps.Map(e.find(&quot;div&quot;)[1], h), r.nggmap_id = k.generate(), d = !1, r ? (a.deferred.resolve(r), n()) : google.maps.event.addListener(r, &quot;tilesloaded &quot;, function (b) {
						return a.deferred.resolve(b), n()
					}), google.maps.event.addListener(r, &quot;dragstart&quot;, function () {
						return d = !0, _.defer(function () {
							return a.$apply(function (a) {
								return null != a.dragging ? a.dragging = d : void 0
							})
						})
					}), google.maps.event.addListener(r, &quot;dragend&quot;, function () {
						return d = !1, _.defer(function () {
							return a.$apply(function (a) {
								return null != a.dragging ? a.dragging = d : void 0
							})
						})
					}), google.maps.event.addListener(r, &quot;drag&quot;, function () {
						var b;
						return b = r.center, _.defer(function () {
							return a.$apply(function (a) {
								return angular.isDefined(a.center.type) ? (a.center.coordinates[1] = b.lat(), a.center.coordinates[0] = b.lng()) : (a.center.latitude = b.lat(), a.center.longitude = b.lng())
							})
						})
					}), google.maps.event.addListener(r, &quot;zoom_changed&quot;, function () {
						return a.zoom !== r.zoom ? _.defer(function () {
							return a.$apply(function (a) {
								return a.zoom = r.zoom
							})
						}) : void 0
					}), o = !1, google.maps.event.addListener(r, &quot;center_changed&quot;, function () {
						var b;
						return b = r.center, o ? void 0 : _.defer(function () {
							return a.$apply(function (a) {
								if (!r.dragging)if (angular.isDefined(a.center.type)) {
									if (a.center.coordinates[1] !== b.lat() &amp;&amp; (a.center.coordinates[1] = b.lat()), a.center.coordinates[0] !== b.lng())return a.center.coordinates[0] = b.lng()
								} else if (a.center.latitude !== b.lat() &amp;&amp; (a.center.latitude = b.lat()), a.center.longitude !== b.lng())return a.center.longitude = b.lng()
							})
						})
					}), google.maps.event.addListener(r, &quot;idle&quot;, function () {
						var b, c, d;
						return b = r.getBounds(), c = b.getNorthEast(), d = b.getSouthWest(), _.defer(function () {
							return a.$apply(function (a) {
								return null !== a.bounds &amp;&amp; void 0 !== a.bounds &amp;&amp; void 0 !== a.bounds ? (a.bounds.northeast = {
									latitude: c.lat(),
									longitude: c.lng()
								}, a.bounds.southwest = {latitude: d.lat(), longitude: d.lng()}) : void 0
							})
						})
					}), angular.isDefined(a.events) &amp;&amp; null !== a.events &amp;&amp; angular.isObject(a.events)) {
					g = function (b) {
						return function () {
							return a.events[b].apply(a, [r, b, arguments])
						}
					};
					for (f in a.events)a.events.hasOwnProperty(f) &amp;&amp; angular.isFunction(a.events[f]) &amp;&amp; google.maps.event.addListener(r, f, g(f))
				}
				return r.getOptions = function () {
					return h
				}, a.map = r, null != c.control &amp;&amp; null != a.control &amp;&amp; (a.control.refresh = function (a) {
					var b;
					if (null != r)return google.maps.event.trigger(r, &quot;resize&quot;), null != (null != a ? a.latitude : void 0) &amp;&amp; null != (null != a ? a.latitude : void 0) ? (b = s.getCoords(a), s.isTrue(c.pan) ? r.panTo(b) : r.setCenter(b)) : void 0
				}, a.control.getGMap = function () {
					return r
				}, a.control.getMapOptions = function () {
					return h
				}), a.$watch(&quot;center&quot;, function (b) {
					var e;
					return e = s.getCoords(b), e.lat() !== r.center.lat() || e.lng() !== r.center.lng() ? (o = !0, d || (s.validateCoords(b) || l.error(&quot;Invalid center for newValue: &quot; + JSON.stringify(b)), s.isTrue(c.pan) &amp;&amp; a.zoom === r.zoom ? r.panTo(e) : r.setCenter(e)), o = !1) : void 0
				}, !0), a.$watch(&quot;zoom&quot;, function (a) {
					return a !== r.zoom ? _.defer(function () {
						return r.setZoom(a)
					}) : void 0
				}), a.$watch(&quot;bounds&quot;, function (a, b) {
					var c, d, e;
					if (a !== b)return null == a.northeast.latitude || null == a.northeast.longitude || null == a.southwest.latitude || null == a.southwest.longitude ? void l.error(&quot;Invalid map bounds for new value: &quot; + JSON.stringify(a)) : (d = new google.maps.LatLng(a.northeast.latitude, a.northeast.longitude), e = new google.maps.LatLng(a.southwest.latitude, a.southwest.longitude), c = new google.maps.LatLngBounds(e, d), r.fitBounds(c))
				}), a.$watch(&quot;options&quot;, function (a, b) {
					return _.isEqual(a, b) || (i.options = a, null == r) ? void 0 : r.setOptions(i)
				}, !0), a.$watch(&quot;styles&quot;, function (a, b) {
					return _.isEqual(a, b) || (i.styles = a, null == r) ? void 0 : r.setOptions(i)
				}, !0)
			}, d
		}(g)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Marker&quot;, [&quot;IMarker&quot;, &quot;MarkerParentModel&quot;, &quot;MarkerManager&quot;, function (b, d, e) {
		var f;
		return f = function (f) {
			function g() {
				this.link = a(this.link, this), g.__super__.constructor.call(this), this.template = &#039;&lt;span class=&quot;angular-google-map-marker&quot; ng-transclude&gt;&lt;/span&gt;&#039;, this.$log.info(this)
			}

			return c(g, f), g.prototype.controller = [&quot;$scope&quot;, &quot;$element&quot;, function (a, c) {
				return a.ctrlType = &quot;Marker&quot;, b.handle(a, c)
			}], g.prototype.link = function (a, c, f, g) {
				var h, i = this;
				return a.fit &amp;&amp; (h = !0), b.mapPromise(a, g).then(function (b) {
					return i.gMarkerManager || (i.gMarkerManager = new e(b)), new d(a, c, f, b, i.$timeout, i.gMarkerManager, h), a.deferred.resolve(), null != a.control ? a.control.getGMarkers = i.gMarkerManager.getGMarkers : void 0
				})
			}, g
		}.call(this, b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Markers&quot;, [&quot;IMarker&quot;, &quot;MarkersParentModel&quot;, function (b, d) {
		var e;
		return e = function (e) {
			function f(b) {
				this.link = a(this.link, this), f.__super__.constructor.call(this, b), this.template = &#039;&lt;span class=&quot;angular-google-map-markers&quot; ng-transclude&gt;&lt;/span&gt;&#039;, this.scope = _.extend(this.scope || {}, {
					idKey: &quot;=idkey&quot;,
					doRebuildAll: &quot;=dorebuildall&quot;,
					models: &quot;=models&quot;,
					doCluster: &quot;=docluster&quot;,
					clusterOptions: &quot;=clusteroptions&quot;,
					clusterEvents: &quot;=clusterevents&quot;,
					isLabel: &quot;=islabel&quot;
				}), this.$timeout = b, this.$log.info(this)
			}

			return c(f, e), f.prototype.controller = [&quot;$scope&quot;, &quot;$element&quot;, function (a, c) {
				return a.ctrlType = &quot;Markers&quot;, b.handle(a, c)
			}], f.prototype.link = function (a, c, e, f) {
				var g = this;
				return b.mapPromise(a, f).then(function (b) {
					var f;
					return f = new d(a, c, e, b, g.$timeout), a.deferred.resolve(), null != a.control ? (a.control.getGMarkers = function () {
						var a;
						return null != (a = f.gMarkerManager) ? a.getGMarkers() : void 0
					}, a.control.getChildMarkers = function () {
						return f.markerModels
					}) : void 0
				})
			}, f
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Polyline&quot;, [&quot;IPolyline&quot;, &quot;$timeout&quot;, &quot;array-sync&quot;, &quot;PolylineChildModel&quot;, function (b, d, e, f) {
		var g, h;
		return g = function (d) {
			function e() {
				return this.link = a(this.link, this), h = e.__super__.constructor.apply(this, arguments)
			}

			return c(e, d), e.prototype.link = function (a, c, d, e) {
				var g = this;
				return angular.isUndefined(a.path) || null === a.path || !this.validatePath(a.path) ? void this.$log.error(&quot;polyline: no valid path attribute found&quot;) : b.mapPromise(a, e).then(function (b) {
					return new f(a, d, b, g.DEFAULTS)
				})
			}, e
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Polylines&quot;, [&quot;IPolyline&quot;, &quot;$timeout&quot;, &quot;array-sync&quot;, &quot;PolylinesParentModel&quot;, function (b, d, e, f) {
		var g;
		return g = function (b) {
			function d() {
				this.link = a(this.link, this), d.__super__.constructor.call(this), this.scope.idKey = &quot;=idkey&quot;, this.scope.models = &quot;=models&quot;, this.$log.info(this)
			}

			return c(d, b), d.prototype.link = function (a, b, c, d) {
				var e = this;
				return angular.isUndefined(a.path) || null === a.path ? void this.$log.error(&quot;polylines: no valid path attribute found&quot;) : a.models ? d.getScope().deferred.promise.then(function (d) {
					return new f(a, b, c, d, e.DEFAULTS)
				}) : void this.$log.error(&quot;polylines: no models found to create from&quot;)
			}, d
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Window&quot;, [&quot;IWindow&quot;, &quot;GmapUtil&quot;, &quot;WindowChildModel&quot;, function (b, d, e) {
		var f;
		return f = function (b) {
			function f(b, c, d, e) {
				this.init = a(this.init, this), this.link = a(this.link, this), f.__super__.constructor.call(this, b, c, d, e), this.require = [&quot;^googleMap&quot;, &quot;^?marker&quot;], this.template = &#039;&lt;span class=&quot;angular-google-maps-window&quot; ng-transclude&gt;&lt;/span&gt;&#039;, this.$log.info(this), this.childWindows = []
			}

			return c(f, b), f.include(d), f.prototype.link = function (a, b, c, d) {
				var e, f = this;
				return e = d[0].getScope(), e.deferred.promise.then(function (e) {
					var g, h, i;
					return g = !0, angular.isDefined(c.isiconvisibleonclick) &amp;&amp; (g = a.isIconVisibleOnClick), (h = d.length &gt; 1 &amp;&amp; null != d[1] ? d[1] : void 0) ? (i = h.getScope(), i.deferred.promise.then(function () {
						return f.init(a, b, g, e, i)
					})) : void f.init(a, b, g, e)
				})
			}, f.prototype.init = function (a, b, c, d, f) {
				var g, h, i, j, k, l = this;
				return g = null != a.options ? a.options : {}, i = null != a &amp;&amp; this.validateCoords(a.coords), null != f &amp;&amp; (h = f.gMarker, f.$watch(&quot;coords&quot;, function (a, b) {
					return null == f.gMarker || k.markerCtrl || (k.markerCtrl = h, k.handleClick(!0)), l.validateCoords(a) ? angular.equals(a, b) ? void 0 : k.getLatestPosition(l.getCoords(a)) : k.hideWindow()
				}, !0)), j = i ? this.createWindowOptions(h, a, b.html(), g) : g, null != d &amp;&amp; (k = new e({}, a, j, c, d, h, b), this.childWindows.push(k), a.$on(&quot;$destroy&quot;, function () {
					return l.childWindows = _.withoutObjects(l.childWindows, [k], function (a, b) {
						return a.scope.$id === b.scope.$id
					})
				})), null != a.control &amp;&amp; (a.control.getGWindows = function () {
					return l.childWindows.map(function (a) {
						return a.gWin
					})
				}, a.control.getChildWindows = function () {
					return l.childWindows
				}), null != this.onChildCreation &amp;&amp; null != k ? this.onChildCreation(k) : void 0
			}, f
		}(b)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps.directives.api&quot;).factory(&quot;Windows&quot;, [&quot;IWindow&quot;, &quot;WindowsParentModel&quot;, function (b, d) {
		var e;
		return e = function (b) {
			function e(b, c, d, f, g) {
				this.link = a(this.link, this);
				var h;
				e.__super__.constructor.call(this, b, c, d, f), h = this, this.$interpolate = g, this.require = [&quot;^googleMap&quot;, &quot;^?markers&quot;], this.template = &#039;&lt;span class=&quot;angular-google-maps-windows&quot; ng-transclude&gt;&lt;/span&gt;&#039;, this.scope.idKey = &quot;=idkey&quot;, this.scope.doRebuildAll = &quot;=dorebuildall&quot;, this.scope.models = &quot;=models&quot;, this.$log.info(this)
			}

			return c(e, b), e.prototype.link = function (a, b, c, e) {
				var f;
				return f = new d(a, b, c, e, this.$timeout, this.$compile, this.$http, this.$templateCache, this.$interpolate), null != a.control ? (a.control.getGWindows = function () {
					return f.windows.map(function (a) {
						return a.gWin
					})
				}, a.control.getChildWindows = function () {
					return f.windows
				}) : void 0
			}, e
		}(b)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;googleMap&quot;, [&quot;Map&quot;, function (a) {
		return new a
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;marker&quot;, [&quot;$timeout&quot;, &quot;Marker&quot;, function (a, b) {
		return new b(a)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;markers&quot;, [&quot;$timeout&quot;, &quot;Markers&quot;, function (a, b) {
		return new b(a)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	}, b = {}.hasOwnProperty, c = function (a, c) {
		function d() {
			this.constructor = a
		}

		for (var e in c)b.call(c, e) &amp;&amp; (a[e] = c[e]);
		return d.prototype = c.prototype, a.prototype = new d, a.__super__ = c.prototype, a
	};
	angular.module(&quot;google-maps&quot;).directive(&quot;markerLabel&quot;, [&quot;$timeout&quot;, &quot;ILabel&quot;, &quot;MarkerLabelChildModel&quot;, &quot;GmapUtil&quot;, &quot;nggmap-PropertyAction&quot;, function (b, d, e, f, g) {
		var h;
		return new (h = function (b) {
			function d(b) {
				this.init = a(this.init, this), this.link = a(this.link, this);
				var c;
				d.__super__.constructor.call(this, b), c = this, this.require = &quot;^marker&quot;, this.template = &#039;&lt;span class=&quot;angular-google-maps-marker-label&quot; ng-transclude&gt;&lt;/span&gt;&#039;, this.$log.info(this)
			}

			return c(d, b), d.prototype.link = function (a, b, c, d) {
				var e, f = this;
				return e = d.getScope(), e ? e.deferred.promise.then(function () {
					return f.init(e, a)
				}) : void 0
			}, d.prototype.init = function (a, b) {
				var c, d, f;
				return f = null, c = function () {
					return f ? void 0 : f = new e(a.gMarker, b, a.map)
				}, d = !0, a.$watch(&quot;gMarker&quot;, function () {
					var e, h, i, j;
					return null != a.gMarker &amp;&amp; (i = new g(function () {
						return c(), b.labelContent &amp;&amp; null != f ? f.setOption(&quot;labelContent&quot;, b.labelContent) : void 0
					}, d), e = new g(function () {
						return c(), null != f ? f.setOption(&quot;labelAnchor&quot;, b.labelAnchor) : void 0
					}, d), h = new g(function () {
						return c(), null != f ? f.setOption(&quot;labelClass&quot;, b.labelClass) : void 0
					}, d), j = new g(function () {
						return c(), null != f ? f.setOption(&quot;labelStyle&quot;, b.labelStyle) : void 0
					}, d), b.$watch(&quot;labelContent&quot;, i.sic), b.$watch(&quot;labelAnchor&quot;, e.sic), b.$watch(&quot;labelClass&quot;, h.sic), b.$watch(&quot;labelStyle&quot;, j.sic), d = !1), b.$on(&quot;$destroy&quot;, function () {
						return null != f ? f.destroy() : void 0
					})
				})
			}, d
		}(d))(b)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;polygon&quot;, [&quot;$log&quot;, &quot;$timeout&quot;, &quot;array-sync&quot;, &quot;GmapUtil&quot;, function (a, b, c, d) {
		var e, f;
		return f = function (a) {
			return angular.isDefined(a) &amp;&amp; null !== a &amp;&amp; a === !0 || &quot;1&quot; === a || &quot;y&quot; === a || &quot;true&quot; === a
		}, e = {}, {
			restrict: &quot;EA&quot;,
			replace: !0,
			require: &quot;^googleMap&quot;,
			scope: {
				path: &quot;=path&quot;,
				stroke: &quot;=stroke&quot;,
				clickable: &quot;=&quot;,
				draggable: &quot;=&quot;,
				editable: &quot;=&quot;,
				geodesic: &quot;=&quot;,
				fill: &quot;=&quot;,
				icons: &quot;=icons&quot;,
				visible: &quot;=&quot;,
				&quot;static&quot;: &quot;=&quot;,
				events: &quot;=&quot;,
				zIndex: &quot;=zindex&quot;,
				fit: &quot;=&quot;
			},
			link: function (b, f, g, h) {
				return angular.isUndefined(b.path) || null === b.path || !d.validatePath(b.path) ? void a.error(&quot;polygon: no valid path attribute found&quot;) : h.getScope().deferred.promise.then(function (a) {
					var f, g, h, i, j, k;
					if (g = function (c) {
							var d;
							return d = angular.extend({}, e, {
								map: a,
								path: c,
								strokeColor: b.stroke &amp;&amp; b.stroke.color,
								strokeOpacity: b.stroke &amp;&amp; b.stroke.opacity,
								strokeWeight: b.stroke &amp;&amp; b.stroke.weight,
								fillColor: b.fill &amp;&amp; b.fill.color,
								fillOpacity: b.fill &amp;&amp; b.fill.opacity
							}), angular.forEach({
								clickable: !0,
								draggable: !1,
								editable: !1,
								geodesic: !1,
								visible: !0,
								&quot;static&quot;: !1,
								fit: !1,
								zIndex: 0
							}, function (a, c) {
								return d[c] = angular.isUndefined(b[c]) || null === b[c] ? a : b[c]
							}), d[&quot;static&quot;] &amp;&amp; (d.editable = !1), d
						}, j = d.convertPathPoints(b.path), k = new google.maps.Polygon(g(j)), b.fit &amp;&amp; d.extendMapBounds(a, j), !b[&quot;static&quot;] &amp;&amp; angular.isDefined(b.editable) &amp;&amp; b.$watch(&quot;editable&quot;, function (a, b) {
							return a !== b ? k.setEditable(a) : void 0
						}), angular.isDefined(b.draggable) &amp;&amp; b.$watch(&quot;draggable&quot;, function (a, b) {
							return a !== b ? k.setDraggable(a) : void 0
						}), angular.isDefined(b.visible) &amp;&amp; b.$watch(&quot;visible&quot;, function (a, b) {
							return a !== b ? k.setVisible(a) : void 0
						}), angular.isDefined(b.geodesic) &amp;&amp; b.$watch(&quot;geodesic&quot;, function (a, b) {
							return a !== b ? k.setOptions(g(k.getPath())) : void 0
						}), angular.isDefined(b.stroke) &amp;&amp; angular.isDefined(b.stroke.opacity) &amp;&amp; b.$watch(&quot;stroke.opacity&quot;, function () {
							return k.setOptions(g(k.getPath()))
						}), angular.isDefined(b.stroke) &amp;&amp; angular.isDefined(b.stroke.weight) &amp;&amp; b.$watch(&quot;stroke.weight&quot;, function (a, b) {
							return a !== b ? k.setOptions(g(k.getPath())) : void 0
						}), angular.isDefined(b.stroke) &amp;&amp; angular.isDefined(b.stroke.color) &amp;&amp; b.$watch(&quot;stroke.color&quot;, function (a, b) {
							return a !== b ? k.setOptions(g(k.getPath())) : void 0
						}), angular.isDefined(b.fill) &amp;&amp; angular.isDefined(b.fill.color) &amp;&amp; b.$watch(&quot;fill.color&quot;, function (a, b) {
							return a !== b ? k.setOptions(g(k.getPath())) : void 0
						}), angular.isDefined(b.fill) &amp;&amp; angular.isDefined(b.fill.opacity) &amp;&amp; b.$watch(&quot;fill.opacity&quot;, function (a, b) {
							return a !== b ? k.setOptions(g(k.getPath())) : void 0
						}), angular.isDefined(b.zIndex) &amp;&amp; b.$watch(&quot;zIndex&quot;, function (a, b) {
							return a !== b ? k.setOptions(g(k.getPath())) : void 0
						}), angular.isDefined(b.events) &amp;&amp; null !== b.events &amp;&amp; angular.isObject(b.events)) {
						i = function (a) {
							return function () {
								return b.events[a].apply(b, [k, a, arguments])
							}
						};
						for (h in b.events)b.events.hasOwnProperty(h) &amp;&amp; angular.isFunction(b.events[h]) &amp;&amp; k.addListener(h, i(h))
					}
					return f = c(k.getPath(), b, &quot;path&quot;, function (c) {
						return b.fit ? d.extendMapBounds(a, c) : void 0
					}), b.$on(&quot;$destroy&quot;, function () {
						return k.setMap(null), f ? (f(), f = null) : void 0
					})
				})
			}
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;circle&quot;, [&quot;$log&quot;, &quot;$timeout&quot;, &quot;GmapUtil&quot;, &quot;EventsHelper&quot;, function (a, b, c, d) {
		&quot;use strict&quot;;
		var e;
		return e = {}, {
			restrict: &quot;EA&quot;,
			replace: !0,
			require: &quot;^googleMap&quot;,
			scope: {
				center: &quot;=center&quot;,
				radius: &quot;=radius&quot;,
				stroke: &quot;=stroke&quot;,
				fill: &quot;=fill&quot;,
				clickable: &quot;=&quot;,
				draggable: &quot;=&quot;,
				editable: &quot;=&quot;,
				geodesic: &quot;=&quot;,
				icons: &quot;=icons&quot;,
				visible: &quot;=&quot;,
				events: &quot;=&quot;
			},
			link: function (f, g, h, i) {
				return i.getScope().deferred.promise.then(function (g) {
					var h, i;
					return h = function () {
						var b;
						return c.validateCoords(f.center) ? (b = angular.extend({}, e, {
							map: g,
							center: c.getCoords(f.center),
							radius: f.radius,
							strokeColor: f.stroke &amp;&amp; f.stroke.color,
							strokeOpacity: f.stroke &amp;&amp; f.stroke.opacity,
							strokeWeight: f.stroke &amp;&amp; f.stroke.weight,
							fillColor: f.fill &amp;&amp; f.fill.color,
							fillOpacity: f.fill &amp;&amp; f.fill.opacity
						}), angular.forEach({
							clickable: !0,
							draggable: !1,
							editable: !1,
							geodesic: !1,
							visible: !0
						}, function (a, c) {
							return b[c] = angular.isUndefined(f[c]) || null === f[c] ? a : f[c]
						}), b) : void a.error(&quot;circle: no valid center attribute found&quot;)
					}, i = new google.maps.Circle(h()), f.$watchCollection(&quot;center&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watchCollection(&quot;stroke&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watchCollection(&quot;fill&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watch(&quot;radius&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watch(&quot;clickable&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watch(&quot;editable&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watch(&quot;draggable&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watch(&quot;visible&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), f.$watch(&quot;geodesic&quot;, function (a, b) {
						return a !== b ? i.setOptions(h()) : void 0
					}), d.setEvents(i, f, f), google.maps.event.addListener(i, &quot;radius_changed&quot;, function () {
						return f.radius = i.getRadius(), b(function () {
							return f.$apply()
						})
					}), google.maps.event.addListener(i, &quot;center_changed&quot;, function () {
						return angular.isDefined(f.center.type) ? (f.center.coordinates[1] = i.getCenter().lat(), f.center.coordinates[0] = i.getCenter().lng()) : (f.center.latitude = i.getCenter().lat(), f.center.longitude = i.getCenter().lng()), b(function () {
							return f.$apply()
						})
					}), f.$on(&quot;$destroy&quot;, function () {
						return i.setMap(null)
					})
				})
			}
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;polyline&quot;, [&quot;Polyline&quot;, function (a) {
		return new a
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;polylines&quot;, [&quot;Polylines&quot;, function (a) {
		return new a
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;rectangle&quot;, [&quot;$log&quot;, &quot;$timeout&quot;, function (a) {
		var b, c, d, e, f;
		return f = function (a) {
			return angular.isUndefined(a.sw.latitude) || angular.isUndefined(a.sw.longitude) || angular.isUndefined(a.ne.latitude) || angular.isUndefined(a.ne.longitude) ? !1 : !0
		}, c = function (a) {
			var b;
			return b = new google.maps.LatLngBounds(new google.maps.LatLng(a.sw.latitude, a.sw.longitude), new google.maps.LatLng(a.ne.latitude, a.ne.longitude))
		}, d = function (a, b) {
			return a.fitBounds(b)
		}, e = function (a) {
			return angular.isDefined(a) &amp;&amp; null !== a &amp;&amp; a === !0 || &quot;1&quot; === a || &quot;y&quot; === a || &quot;true&quot; === a
		}, b = {}, {
			restrict: &quot;ECA&quot;,
			require: &quot;^googleMap&quot;,
			replace: !0,
			scope: {bounds: &quot;=&quot;, stroke: &quot;=&quot;, clickable: &quot;=&quot;, draggable: &quot;=&quot;, editable: &quot;=&quot;, fill: &quot;=&quot;, visible: &quot;=&quot;},
			link: function (g, h, i, j) {
				return angular.isUndefined(g.bounds) || null === g.bounds || angular.isUndefined(g.bounds.sw) || null === g.bounds.sw || angular.isUndefined(g.bounds.ne) || null === g.bounds.ne || !f(g.bounds) ? void a.error(&quot;rectangle: no valid bound attribute found&quot;) : j.getScope().deferred.promise.then(function (f) {
					var h, j, k, l;
					return h = function (a) {
						var c;
						return c = angular.extend({}, b, {
							map: f,
							bounds: a,
							strokeColor: g.stroke &amp;&amp; g.stroke.color,
							strokeOpacity: g.stroke &amp;&amp; g.stroke.opacity,
							strokeWeight: g.stroke &amp;&amp; g.stroke.weight,
							fillColor: g.fill &amp;&amp; g.fill.color,
							fillOpacity: g.fill &amp;&amp; g.fill.opacity
						}), angular.forEach({clickable: !0, draggable: !1, editable: !1, visible: !0}, function (a, b) {
							return c[b] = angular.isUndefined(g[b]) || null === g[b] ? a : g[b]
						}), c
					}, k = new google.maps.Rectangle(h(c(g.bounds))), e(i.fit) &amp;&amp; d(f, bounds), j = !1, google.maps.event.addListener(k, &quot;mousedown&quot;, function () {
						google.maps.event.addListener(k, &quot;mousemove&quot;, function () {
							return j = !0, _.defer(function () {
								return g.$apply(function (a) {
									return null != a.dragging ? a.dragging = j : void 0
								})
							})
						}), google.maps.event.addListener(k, &quot;mouseup&quot;, function () {
							return google.maps.event.clearListeners(k, &quot;mousemove&quot;), google.maps.event.clearListeners(k, &quot;mouseup&quot;), j = !1, _.defer(function () {
								return g.$apply(function (a) {
									return null != a.dragging ? a.dragging = j : void 0
								})
							})
						})
					}), l = !1, google.maps.event.addListener(k, &quot;bounds_changed&quot;, function () {
						var a, b, c;
						return a = k.getBounds(), b = a.getNorthEast(), c = a.getSouthWest(), l ? void 0 : _.defer(function () {
							return g.$apply(function (a) {
								k.dragging || null !== a.bounds &amp;&amp; void 0 !== a.bounds &amp;&amp; void 0 !== a.bounds &amp;&amp; (a.bounds.ne = {
									latitude: b.lat(),
									longitude: b.lng()
								}, a.bounds.sw = {latitude: c.lat(), longitude: c.lng()})
							})
						})
					}), g.$watch(&quot;bounds&quot;, function (b, c) {
						var d;
						if (!_.isEqual(b, c))return l = !0, j || ((null == b.sw.latitude || null == b.sw.longitude || null == b.ne.latitude || null == b.ne.longitude) &amp;&amp; a.error(&quot;Invalid bounds for newValue: &quot; + JSON.stringify(b)), d = new google.maps.LatLngBounds(new google.maps.LatLng(b.sw.latitude, b.sw.longitude), new google.maps.LatLng(b.ne.latitude, b.ne.longitude)), k.setBounds(d)), l = !1
					}, !0), angular.isDefined(g.editable) &amp;&amp; g.$watch(&quot;editable&quot;, function (a) {
						return k.setEditable(a)
					}), angular.isDefined(g.draggable) &amp;&amp; g.$watch(&quot;draggable&quot;, function (a) {
						return k.setDraggable(a)
					}), angular.isDefined(g.visible) &amp;&amp; g.$watch(&quot;visible&quot;, function (a) {
						return k.setVisible(a)
					}), angular.isDefined(g.stroke) &amp;&amp; (angular.isDefined(g.stroke.color) &amp;&amp; g.$watch(&quot;stroke.color&quot;, function () {
						return k.setOptions(h(k.getBounds()))
					}), angular.isDefined(g.stroke.weight) &amp;&amp; g.$watch(&quot;stroke.weight&quot;, function () {
						return k.setOptions(h(k.getBounds()))
					}), angular.isDefined(g.stroke.opacity) &amp;&amp; g.$watch(&quot;stroke.opacity&quot;, function () {
						return k.setOptions(h(k.getBounds()))
					})), angular.isDefined(g.fill) &amp;&amp; (angular.isDefined(g.fill.color) &amp;&amp; g.$watch(&quot;fill.color&quot;, function () {
						return k.setOptions(h(k.getBounds()))
					}), angular.isDefined(g.fill.opacity) &amp;&amp; g.$watch(&quot;fill.opacity&quot;, function () {
						return k.setOptions(h(k.getBounds()))
					})), g.$on(&quot;$destroy&quot;, function () {
						return k.setMap(null)
					})
				})
			}
		}
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;window&quot;, [&quot;$timeout&quot;, &quot;$compile&quot;, &quot;$http&quot;, &quot;$templateCache&quot;, &quot;Window&quot;, function (a, b, c, d, e) {
		return new e(a, b, c, d)
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;windows&quot;, [&quot;$timeout&quot;, &quot;$compile&quot;, &quot;$http&quot;, &quot;$templateCache&quot;, &quot;$interpolate&quot;, &quot;Windows&quot;, function (a, b, c, d, e, f) {
		return new f(a, b, c, d, e)
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	};
	angular.module(&quot;google-maps&quot;).directive(&quot;layer&quot;, [&quot;$timeout&quot;, &quot;Logger&quot;, &quot;LayerParentModel&quot;, function (b, c, d) {
		var e;
		return new (e = function () {
			function b() {
				this.link = a(this.link, this), this.$log = c, this.restrict = &quot;EMA&quot;, this.require = &quot;^googleMap&quot;, this.priority = -1, this.transclude = !0, this.template = &#039;&lt;span class=&quot;angular-google-map-layer&quot; ng-transclude&gt;&lt;/span&gt;&#039;, this.replace = !0, this.scope = {
					show: &quot;=show&quot;,
					type: &quot;=type&quot;,
					namespace: &quot;=namespace&quot;,
					options: &quot;=options&quot;,
					onCreated: &quot;&amp;oncreated&quot;
				}
			}

			return b.prototype.link = function (a, b, c, e) {
				return e.getScope().deferred.promise.then(function (e) {
					return null != a.onCreated ? new d(a, b, c, e, a.onCreated) : new d(a, b, c, e)
				})
			}, b
		}())
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;mapControl&quot;, [&quot;Control&quot;, function (a) {
		return new a
	}])
}.call(this),function () {
	angular.module(&quot;google-maps&quot;).directive(&quot;FreeDrawPolygons&quot;.ns(), [&quot;FreeDrawPolygons&quot;, function (a) {
		return new a
	}])
}.call(this),function () {
	var a = function (a, b) {
		return function () {
			return a.apply(b, arguments)
		}
	};
	angular.module(&quot;google-maps&quot;).directive(&quot;mapType&quot;, [&quot;$timeout&quot;, &quot;Logger&quot;, &quot;MapTypeParentModel&quot;, function (b, c, d) {
		var e;
		return new (e = function () {
			function b() {
				this.link = a(this.link, this), this.$log = c, this.restrict = &quot;EMA&quot;, this.require = &quot;^googleMap&quot;, this.priority = -1, this.transclude = !0, this.template = &#039;&lt;span class=&quot;angular-google-map-layer&quot; ng-transclude&gt;&lt;/span&gt;&#039;, this.replace = !0, this.scope = {
					show: &quot;=show&quot;,
					options: &quot;=options&quot;,
					refresh: &quot;=refresh&quot;,
					id: &quot;@&quot;
				}
			}

			return b.prototype.link = function (a, b, c, e) {
				return e.getScope().deferred.promise.then(function (e) {
					return new d(a, b, c, e)
				})
			}, b
		}())
	}])
}.call(this),angular.module(&quot;google-maps.wrapped&quot;).service(&quot;uuid&quot;.ns(), function () {
	function a() {
	}

	return a.generate = function () {
		var b = a._gri, c = a._ha;
		return c(b(32), 8) + &quot;-&quot; + c(b(16), 4) + &quot;-&quot; + c(16384 | b(12), 4) + &quot;-&quot; + c(32768 | b(14), 4) + &quot;-&quot; + c(b(48), 12)
	}, a._gri = function (a) {
		return 0 &gt; a ? 0 / 0 : 30 &gt;= a ? 0 | Math.random() * (1 &lt;&lt; a) : 53 &gt;= a ? (0 | 1073741824 * Math.random()) + 1073741824 * (0 | Math.random() * (1 &lt;&lt; a - 30)) : 0 / 0
	}, a._ha = function (a, b) {
		for (var c = a.toString(16), d = b - c.length, e = &quot;0&quot;; d &gt; 0; d &gt;&gt;&gt;= 1, e += e)1 &amp; d &amp;&amp; (c = e + c);
		return c
	}, a
}),function () {
	var a = {}.hasOwnProperty, b = function (b, c) {
		function d() {
			this.constructor = b
		}

		for (var e in c)a.call(c, e) &amp;&amp; (b[e] = c[e]);
		return d.prototype = c.prototype, b.prototype = new d, b.__super__ = c.prototype, b
	};
	window.NgMapCluster = function (a) {
		function c(a) {
			c.__super__.constructor.call(this, a), this.markers_ = new window.PropMap
		}

		return b(c, a), c.prototype.addMarker = function (a) {
			var b, c;
			if (this.isMarkerAlreadyAdded_(a)) {
				var d = this.markers_.get(a.key);
				if (d.getPosition().lat() == a.getPosition().lat() &amp;&amp; d.getPosition().lon() == a.getPosition().lon())return !1
			}
			if (this.center_) {
				if (this.averageCenter_) {
					var e = this.markers_.length + 1, f = (this.center_.lat() * (e - 1) + a.getPosition().lat()) / e, g = (this.center_.lng() * (e - 1) + a.getPosition().lng()) / e;
					this.center_ = new google.maps.LatLng(f, g), this.calculateBounds_()
				}
			} else this.center_ = a.getPosition(), this.calculateBounds_();
			return a.isAdded = !0, this.markers_.push(a), b = this.markers_.length, c = this.markerClusterer_.getMaxZoom(), null !== c &amp;&amp; this.map_.getZoom() &gt; c ? a.getMap() !== this.map_ &amp;&amp; a.setMap(this.map_) : b &lt; this.minClusterSize_ ? a.getMap() !== this.map_ &amp;&amp; a.setMap(this.map_) : b === this.minClusterSize_ ? this.markers_.values().forEach(function (a) {
				a.setMap(null)
			}) : a.setMap(null), !0
		}, c.prototype.isMarkerAlreadyAdded_ = function (a) {
			return _.isNullOrUndefined(this.markers_.get(a.key))
		}, c.prototype.getBounds = function () {
			var a, b = new google.maps.LatLngBounds(this.center_, this.center_), c = this.getMarkers().values();
			for (a = 0; a &lt; c.length; a++)b.extend(c[a].getPosition());
			return b
		}, c.prototype.remove = function () {
			this.clusterIcon_.setMap(null), this.markers_ = new PropMap, delete this.markers_
		}, c
	}(Cluster), window.NgMapMarkerClusterer = function (a) {
		function c(a, b, d) {
			c.__super__.constructor.call(this, a, b, d), this.markers_ = new window.PropMap
		}

		return b(c, a), c.prototype.clearMarkers = function () {
			this.resetViewport_(!0), this.markers_ = new PropMap
		}, c.prototype.removeMarker_ = function (a) {
			return this.markers_.get(a.key) ? (a.setMap(null), this.markers_.remove(a.key), !0) : !1
		}, c.prototype.createClusters_ = function (a) {
			var b, c, d, e = this;
			if (this.ready_) {
				0 === a &amp;&amp; (google.maps.event.trigger(this, &quot;clusteringbegin&quot;, this), &quot;undefined&quot; != typeof this.timerRefStatic &amp;&amp; (clearTimeout(this.timerRefStatic), delete this.timerRefStatic)), d = this.getMap().getZoom() &gt; 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
				var f = this.getExtendedBounds(d), g = Math.min(a + this.batchSize_, this.markers_.length);
				for (b = a; g &gt; b; b++)c = this.markers_.values()[b], !c.isAdded &amp;&amp; this.isMarkerInBounds_(c, f) &amp;&amp; (!this.ignoreHidden_ || this.ignoreHidden_ &amp;&amp; c.getVisible()) &amp;&amp; this.addToClosestCluster_(c);
				if (g &lt; this.markers_.length)this.timerRefStatic = setTimeout(function () {
					e.createClusters_(g)
				}, 0); else {
					for (b = 0; b &lt; this.clusters_.length; b++)this.clusters_[b].updateIcon_();
					delete this.timerRefStatic, google.maps.event.trigger(this, &quot;clusteringend&quot;, this)
				}
			}
		}, c.prototype.addToClosestCluster_ = function (a) {
			var b, c, d, e, f = 4e4, g = null;
			for (b = 0; b &lt; this.clusters_.length; b++)d = this.clusters_[b], e = d.getCenter(), e &amp;&amp; (c = this.distanceBetweenPoints_(e, a.getPosition()), f &gt; c &amp;&amp; (f = c, g = d));
			g &amp;&amp; g.isMarkerInClusterBounds(a) ? g.addMarker(a) : (d = new NgMapCluster(this), d.addMarker(a), this.clusters_.push(d))
		}, c.prototype.redraw_ = function () {
			this.createClusters_(0)
		}, c.prototype.resetViewport_ = function (a) {
			var b;
			for (b = 0; b &lt; this.clusters_.length; b++)this.clusters_[b].remove();
			this.clusters_ = [], this.markers_.values().forEach(function (b) {
				b.isAdded = !1, a &amp;&amp; b.setMap(null)
			})
		}, MarkerClusterer.prototype.extend = function (a, b) {
			return function (a) {
				var b;
				for (b in a.prototype)&quot;constructor&quot; !== b &amp;&amp; (this.prototype[b] = a.prototype[b]);
				return this
			}.apply(a, [b])
		}, c
	}(MarkerClusterer)
}.call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
